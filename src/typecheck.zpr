import "std/core.zpr";
import "std/vector.zpr";
import "std/math.zpr";

var tc_typeStack = new_vector();
var tc_definedTypes = new_vector();

var tc_checkingLoop = false;

function Type.is_integral(): bool {
	return this.indirection == 0 && (
		this.type == DATA_TYPE_INT ||
		this.type == DATA_TYPE_I8 ||
		this.type == DATA_TYPE_I16 ||
		this.type == DATA_TYPE_I32 ||
		this.type == DATA_TYPE_I64
	);
}

function Type.is_void(): bool {
	return this.indirection == 0 && this.type == DATA_TYPE_VOID;
}

function Type.is_structural(): bool {
	resolve_type(this);
	return this.is_structural_base() && this.indirection == 0;
}

function Type.is_structural_base(): bool {
	resolve_type(this);
	return this.type == DATA_TYPE_STRUCT || this.type == DATA_TYPE_UNION;
}

function Type.assignable(b: Type*): bool {
	resolve_type(this);
	resolve_type(b);

	if(b.type == DATA_TYPE_ANY && b.indirection == 0) {
		return true;
	}

	if((this.type == DATA_TYPE_ANY || b.type == DATA_TYPE_ANY) && this.indirection >= 1  && b.indirection >= 1) {
		return true;
	}

	if(this.is_integral() && b.is_integral()) {
		return true;
	}

	if(this.type == DATA_TYPE_STRUCT && b.type == DATA_TYPE_STRUCT) {
		if(this.indirection != b.indirection) return false;

		if(this.name.equals(&b.name) && this.size() == b.size()) {
			return true;
		}

		return false;
	}

	//TODO Support assigning unions properly

	return this.type == b.type && this.indirection == b.indirection;
}

function Type.size_offset(): int {
	if(this.isArray) {
		var subType = copy_type(this);
		subType.indirection = this.indirection - 1;

		return subType.size() * this.arrayLength;
	}
	return this.size();
}

function Type.size(): int {
	resolve_type(this);
	if(this.indirection != 0) return 8;

	if(this.type == DATA_TYPE_INT) return 8;
	if(this.type == DATA_TYPE_I8) return 1;
	if(this.type == DATA_TYPE_I16) return 2;
	if(this.type == DATA_TYPE_I32) return 4;
	if(this.type == DATA_TYPE_I64) return 8;
	if(this.type == DATA_TYPE_ANY) return 8;
	if(this.type == DATA_TYPE_STRUCT) {
		var size = 0;
		var unionSize = 0;
		var inUnion = false;
		for(var i = 0; i < this.fields.size; ++i) {
			var field: Node* = this.fields.at(i);

			// In the case of an anon union,
			// the largest field should account for all fields
			// and the individual fields should not be sized onto the struct
			if(field.variable.unionField) {
				inUnion = true;
				var memSize = field.variable.type.size_offset();
				unionSize = memSize > unionSize ? memSize : unionSize;
			}
			else {
				if(inUnion) {
					inUnion = false;
					size += unionSize;
				}
				size += field.variable.type.size_offset();
			}
		}

		if(inUnion) {
			size += unionSize;
		}

		return size;
	}
	if(this.type == DATA_TYPE_UNION) {
		var size = 0;
		for(var i = 0; i < this.fields.size; ++i) {
			var memSize = (this.fields.at(i) as Node*).variable.type.size_offset();
			size = memSize > size ? memSize : size;
		}
		return size;
	}

	eputsln("Unreachable - VOID_TYPE.size");
	exit(1);
	return 0;
}

function Node.print_position() {
	this.position.print_position();
}

function Token.print_position() {
	eputs("["); eputs(this.filename); eputs(":"); eputd(this.line); eputs("] Error ");

	if(this.type == TOKEN_EOF) {
		eputs("@ EOF");
	}
	else {
		eputs("@ '"); eput_token_string(this); eputs("'");
	}
	eputs(": ");
}

function lookup_type(name: Name*): Type* {
	for(var i = 0; i < tc_definedTypes.size; ++i) {
		var type: Type* = tc_definedTypes.at(i);

		//TODO Support namespaces

		if(type.name.equals(name)) {
			return type;
		}
	}

	name.print_position();
	eputs("Unknown type '"); name.eput(); eputsln("'");
	exit(1);

	return null;
}

function resolve_type(type: Type*): Type* {
	if(type.type != DATA_TYPE_UNRESOLVED) return type;
	var resolve = lookup_type(&type.name);

	if(resolve.type == DATA_TYPE_ALIAS) {
		var new = copy_type(resolve.aliased);
		new.indirection = type.indirection;
		new.isArray = type.isArray;
		new.arrayLength = type.arrayLength;
		new.aliased = resolve;
		*type = *new;
		return type;
	}

	var new = copy_type(resolve);
	new.indirection = type.indirection;
	new.isArray = type.isArray;
	new.arrayLength = type.arrayLength;
	*type = *new;
	return type;
}

function Parser.lookup_variable(name: Name*): Node* {
	var block = this.currentBlock;

	//TODO Support namespaces

	while(block != null) {
		var variable = this.lookup_scope_variable(name, block);
		if(variable != null) return variable;
		block = block.block.parent;
	}

	for(var i = 0; i < this.currentFunction.funktion.arguments.size; ++i) {
		var arg: Node* = this.currentFunction.funktion.arguments.at(i);

		if(arg.variable.name.equals(name)) {
			return arg;
		}
	}

	var constant = this.lookup_constant(name);
	if(constant != null) return constant;

	for(var i = 0; i < this.globalVars.size; ++i) {
		var variable: Node* = this.globalVars.at(i);

		if(variable.variable.name.equals(name)) {
			return variable;
		}
	}

	for(var i = 0; i < this.functions.size; ++i) {
		var func: Node* = this.functions.at(i);
		if(func.funktion.name.equals(name) && !func.funktion.isMethod) {
			return func;
		}
	}

	return null;
}

function Parser.lookup_constant(name: Name*): Node* {
	// TODO Support namespaces

	for(var i = 0; i < this.constants.size; ++i) {
		var constant: Node* = this.constants.at(i);
		if(constant.constant.name.equals(name)) {
			return constant;
		}
	}

	return null;
}

function Parser.lookup_scope_variable(name: Name*, block: Node*): Node* {
	for(var i = 0; i < block.block.variables.size; ++i) {
		var variable: Node* = block.block.variables.at(i);

		if(variable.variable.name.equals(name)) {
			return variable;
		}
	}
	return null;
}

function Parser.lookup_same_scope_variable(name: Name*): Node* {
	return this.lookup_scope_variable(name, this.currentBlock);
}

function Parser.lookup_global_variable(name: Name*): Node* {
	for(var i = 0; i < this.globalVars.size; ++i) {
		var variable: Node* = this.globalVars.at(i);

		if(variable.variable.name.equals(name)) {
			return variable;
		}
	}
	return null;
}

function Type.lookup_field(name: Token*): Node* {
	
	for(var i = 0; i < this.fields.size; ++i) {
		var field: Node* = this.fields.at(i);

		if(field.variable.name.name.equals(name)) {
			return field;
		}
	}

	name.print_position();
	eputs("Type "); eputs(type_to_string(this)); eputs(" has no member "); eput_token_string(name); eputln();
	exit(1);

	return null;
}

function Type.lookup_method(name: Name*): Node* {
	resolve_type(this);

	for(var i = 0; i < this.methods.size; ++i) {
		var method: Node* = this.methods.at(i);

		if(method.funktion.name.equals(name)) {
			return method;
		}
	}

	name.print_position();
	eputs("Type "); eputs(type_to_string(this)); eputs(" has no method '"); name.eput(); eputsln("'");
	exit(1);

	return null;
}

function assignment_op_to_node_type(op: int): int {
	if(op == TOKEN_PLUS_EQ) return OP_ADD;
	if(op == TOKEN_MINUS_EQ) return OP_SUB;
	if(op == TOKEN_STAR_EQ) return OP_MUL;
	if(op == TOKEN_SLASH_EQ) return OP_DIV;
	if(op == TOKEN_PERCENT_EQ) return OP_MOD;
	if(op == TOKEN_AMP_EQ) return OP_BWAND;
	if(op == TOKEN_BAR_EQ) return OP_BWOR;
	if(op == TOKEN_XOR_EQ) return OP_XOR;
	if(op == TOKEN_LSH_EQ) return OP_LSH;
	if(op == TOKEN_RSH_EQ) return OP_RSH;

	eputsln("Unreachable in assignment_op_to_node_type");
	exit(1);
	return 0;
}

function synthetic_binary_op(op: Token*, lhs: Node*, rhs: Node*): Node* {
	var type = assignment_op_to_node_type(op.type);
	var node = new_node(type, op);
	node.binary.lhs = lhs;
	node.binary.rhs = rhs;
	return node;
}

function Parser.type_check_addrof(expr: Node*) {
	if(!expr.unary.lvalue) {
		expr.print_position();
		eputsln("Expected lvalue as operand for unary '&'");
		exit(1);
	}

	this.type_check_expr(expr.unary);
	var type: Type* = tc_typeStack.pop();

	var addrType = copy_type(type);
	addrType.indirection = addrType.indirection + 1;

	tc_typeStack.push(addrType);
}

function Parser.type_check_deref(expr: Node*) {
	this.type_check_expr(expr.unary);
	var type: Type* = tc_typeStack.pop();
	resolve_type(type);

	if(type.indirection == 0) {
		expr.print_position();
		eputs("Cannot dereference non-pointer type "); eputs(type_to_string(type)); eputln();
		exit(1);
	}

	var derefType = copy_type(type);
	derefType.indirection = derefType.indirection - 1;

	expr.computedType = derefType;
	tc_typeStack.push(derefType);
}

function Parser.type_check_unary(expr: Node*) {
	if(expr.type == OP_ADDROF) {
		this.type_check_addrof(expr);
		return;
	}
	else if(expr.type == OP_DEREF) {
		this.type_check_deref(expr);
		return;
	}

	this.type_check_expr(expr.unary);

	var type: Type* = tc_typeStack.top();

	if(!type.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot perform operation '"); eputs(node_type_to_string(expr.type)); eputs("' on type "); eputs(type_to_string(type)); eputln();
		exit(1);
	}
}

function Parser.type_check_binary(expr: Node*) {
	this.type_check_expr(expr.binary.lhs);
	var left: Type* = tc_typeStack.pop();

	this.type_check_expr(expr.binary.rhs);
	var right: Type* = tc_typeStack.pop();

	if((expr.type == OP_EQUAL || expr.type == OP_NOT_EQUAL) && left.indirection > 0 && right.indirection > 0 && left.assignable(right)) {
		tc_typeStack.push(INT_TYPE);
		return;
	}

	if(!left.assignable(INT_TYPE) || !right.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot perform operation '"); eputs(node_type_to_string(expr.type)); eputs("' on types "); eputs(type_to_string(left));
		eputs(" and "); eputs(type_to_string(right)); eputln();
		exit(1);
	}

	tc_typeStack.push(left);
}

function Parser.type_check_access_var(expr: Node*) {
	var variable = this.lookup_variable(&expr.variable.name);

	if(variable == null) {
		expr.print_position();
		eputs("Unknown variable '"); expr.variable.name.eput(); eputsln("' in current scope");
		exit(1);
	}

	if(variable.type == AST_DEFINE_VAR) {
		expr.variable.type = variable.variable.type;
		expr.variable.stackOffset = variable.variable.stackOffset;

		var decay = copy_type(expr.variable.type);

		tc_typeStack.push(decay);
	}
	else if(variable.type == AST_DEFINE_GLOBAL_VAR) {
		expr.variable.type = variable.variable.type;
		expr.type = AST_ACCESS_GLOBAL_VAR;
		expr.lvalue = LVALUE_GLOBAL;

		tc_typeStack.push(expr.variable.type);
	}
	else if(variable.type == AST_DEFINE_CONST) {
		var value = variable.constant.value;

		expr.type = AST_INT_LITERAL;
		expr.literal.type = INT_TYPE;
		expr.literal.az.integer = value;

		tc_typeStack.push(INT_TYPE);
	}
	else {
		expr.print_position();
		eputsln("Can only access variables");
		exit(1);
	}
}

function Parser.type_check_call(expr: Node*) {
	var funktion = this.lookup_variable(&expr.funktion.name);

	if(funktion == null) {
		expr.print_position();
		eputs("Unknown variable '"); expr.variable.name.eput(); eputsln("' in current scope");
		exit(1);
	}

	if(funktion.type != AST_FUNCTION) {
		expr.print_position();
		eputsln("Can only call functions");
		exit(1);
	}

	funktion.funktion.used = true;

	if(funktion.funktion.arguments.size != expr.funktion.arguments.size) {
		expr.print_position();
		eputs("Call expected "); eputd(funktion.funktion.arguments.size); eputs(" arguments but got "); eputd(expr.funktion.arguments.size); eputln();
		exit(1);
	}

	for(var i = 0; i < funktion.funktion.arguments.size; ++i) {
		var arg: Node* = expr.funktion.arguments.at(i);
		this.type_check_expr(arg);

		var argType: Type* = tc_typeStack.pop();
		
		var param: Node* = funktion.funktion.arguments.at(i);
		var paramType = param.variable.type;

		if(!argType.assignable(paramType)) {
			expr.print_position();
			eputs("Function argument "); eputd(i + 1); eputs(" expected type "); eputs(type_to_string(paramType)); eputs(" but got ");
			eputs(type_to_string(argType)); eputln();
			exit(1);
		}
	}

	tc_typeStack.push(funktion.funktion.returnType);
}

function Parser.type_check_method_call(expr: Node*) {
	this.type_check_expr(expr.funktion.parent);

	var parentType: Type* = tc_typeStack.pop();
	resolve_type(parentType);

	var name = expr.funktion.name;
	var funktion: Node*;

	if(parentType.type == DATA_TYPE_STRUCT && parentType.indirection == 0) {
		funktion = parentType.lookup_method(&name);
	}
	else if(parentType.type == DATA_TYPE_STRUCT && parentType.indirection == 1 && !parentType.isArray) {
		var copy = copy_type(parentType);
		copy.indirection = copy.indirection - 1;
		funktion = copy.lookup_method(&name);
		parentType = copy;
	}
	else {
		expr.print_position();
		eputs("Cannot access method on type "); eputs(type_to_string(parentType)); eputln();
		exit(1);
	}

	funktion.funktion.used = true;

	expr.funktion.parentType = parentType;

	if(funktion == null) {
		expr.print_position();
		eputs("Unknown method '"); name.eput(); eputs("'' of type "); eputs(type_to_string(parentType)); eputln();
		exit(1);
	}

	if(funktion.type != AST_FUNCTION) {
		expr.print_position();
		eputsln("Can only call functions");
		exit(1);
	}

	if(funktion.funktion.arguments.size - 1 != expr.funktion.arguments.size) {
		expr.print_position();
		eputs("Call expected "); eputd(funktion.funktion.arguments.size - 1); eputs(" arguments but got "); eputd(expr.funktion.arguments.size); eputln();
		exit(1);
	}

	for(var i = 1; i < funktion.funktion.arguments.size; ++i) {
		var arg: Node* = expr.funktion.arguments.at(i - 1);
		this.type_check_expr(arg);

		var argType: Type* = tc_typeStack.pop();
		var paramType = (funktion.funktion.arguments.at(i) as Node*).variable.type;

		if(!argType.assignable(paramType)) {
			expr.print_position();
			eputs("Function argument "); eputd(i - 1); eputs(" expected type "); eputs(type_to_string(paramType)); eputs(" but got ");
			eputs(type_to_string(argType)); eputln();
			exit(1);
		}
	}

	tc_typeStack.push(funktion.funktion.returnType);
}

function Parser.type_check_ternary_expr(expr: Node*) {
	this.type_check_expr(expr.conditional.condition);
	var condition: Type* = tc_typeStack.pop();

	if(!condition.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot use type "); eputs(type_to_string(condition)); eputsln(" as a condition");
		exit(1);
	}

	this.type_check_expr(expr.conditional.doTrue);
	var doTrue: Type* = tc_typeStack.pop();

	this.type_check_expr(expr.conditional.doFalse);
	var doFalse: Type* = tc_typeStack.pop();

	if(!doTrue.assignable(doFalse)) {
		expr.print_position();
		eputs("Cannot conditionally return differing types "); eputs(type_to_string(doTrue)); eputs(" and "); eputs(type_to_string(doFalse)); eputln();
		exit(1);
	}

	tc_typeStack.push(doTrue);
}

function Parser.type_check_access_subscript(expr: Node*) {
	this.type_check_expr(expr.binary.lhs);
	var lhs: Type* = tc_typeStack.pop();

	if(lhs.indirection == 0) {
		expr.print_position();
		eputs("Cannot subscript value type "); eputs(type_to_string(lhs)); eputln();
		exit(1);
	}

	this.type_check_expr(expr.binary.rhs);
	var rhs: Type* = tc_typeStack.pop();

	if(!rhs.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot subscript with index of type "); eputs(type_to_string(rhs)); eputln();
		exit(1);
	}

	var itemType = copy_type(lhs);
	itemType.indirection = itemType.indirection - 1;

	expr.computedType = itemType;

	tc_typeStack.push(itemType);
}

function Parser.type_check_access_member(expr: Node*) {
	this.type_check_expr(expr.member.parent);

	var parentType: Type* = tc_typeStack.pop();
	resolve_type(parentType);

	var name = expr.member.name;
	var field: Node*;

	if(parentType.is_structural_base() && parentType.indirection == 0) {
		field = parentType.lookup_field(name);
	}
	else if(parentType.is_structural_base() && parentType.indirection == 1 && !parentType.isArray) {
		var copy = copy_type(parentType);
		copy.indirection = copy.indirection - 1;
		field = copy.lookup_field(name);
	}
	else {
		expr.print_position();
		eputs("Cannot access member on type "); eputs(type_to_string(parentType)); eputln();
		exit(1);
	}

	expr.member.memberRef = field;

	tc_typeStack.push(field.variable.type);
}

function Parser.type_check_assign(expr: Node*) {
	this.type_check_expr(expr.assignment.lhs);

	if(expr.assignment.lhs.type == AST_INT_LITERAL) {
		expr.print_position();
		eputsln("Cannot re-assign constant values");
		exit(1);
	}

	var lhs: Type* = tc_typeStack.pop();
	resolve_type(lhs);

	if(expr.assignment.op.type != TOKEN_EQ) {
		expr.assignment.rhs = synthetic_binary_op(
			expr.assignment.op,
			expr.assignment.lhs,
			expr.assignment.rhs
		);
	}

	this.type_check_expr(expr.assignment.rhs);

	var rhs: Type* = tc_typeStack.pop();
	resolve_type(rhs);

	if(!rhs.assignable(lhs)) {
		expr.print_position();
		eputs("Cannot assign type "); eputs(type_to_string(rhs)); eputs(" to type "); eputs(type_to_string(lhs));
		eputln();
		exit(1);
	}

	expr.computedType = lhs;

	tc_typeStack.push(lhs);
}

function Parser.type_check_inc_decrement(expr: Node*) {
	if(expr.unary.lvalue == LVALUE_NONE) {
		expr.print_position();
		eputs("Invalid lvalue for '"); eputs(node_type_to_string(expr.type)); eputsln("' operation");
		exit(1);
	}

	this.type_check_expr(expr.unary);

	var type: Type* = tc_typeStack.pop();
	resolve_type(type);

	expr.computedType = type;

	if(!type.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot perform '"); eputs(node_type_to_string(expr.type)); eputs("' on type "); eputs(type_to_string(type));
		eputln();
		exit(1);
	}

	tc_typeStack.push(type);
}

function Parser.type_check_expr(expr: Node*) {
	if(is_unary_op(expr.type)) {
		this.type_check_unary(expr);
	}
	else if(is_binary_op(expr.type)) {
		this.type_check_binary(expr);
	}
	else if(expr.type == AST_INT_LITERAL) {
		tc_typeStack.push(INT_TYPE);
	}
	else if(expr.type == AST_CHAR_LITERAL) {
		tc_typeStack.push(I8_TYPE);
	}
	else if(expr.type == AST_STRING) {
		tc_typeStack.push(STR_TYPE);
	}
	else if(expr.type == AST_ACCESS_VAR || expr.type == AST_ACCESS_GLOBAL_VAR) {
		this.type_check_access_var(expr);
	}
	else if(expr.type == AST_CALL) {
		this.type_check_call(expr);
	}
	else if(expr.type == AST_CALL_METHOD) {
		this.type_check_method_call(expr);
	}
	else if(expr.type == OP_TERNARY) {
		this.type_check_ternary_expr(expr);
	}
	else if(expr.type == OP_SIZEOF) {
		tc_typeStack.push(INT_TYPE);
	}
	else if(expr.type == OP_ACCESS_SUBSCRIPT) {
		this.type_check_access_subscript(expr);
	}
	else if(expr.type == AST_CAST) {
		// NOTE: All casts are completely allowed at the moment. Whether or not this is good
		//       or requires a warning in some cases is to be decided.
		this.type_check_expr(expr.unary);
		resolve_type(expr.computedType);
		tc_typeStack.push(expr.computedType);
	}
	else if(expr.type == OP_ACCESS_MEMBER) {
		this.type_check_access_member(expr);
	}
	else if(expr.type == OP_ASSIGN) {
		this.type_check_assign(expr);
	}
	else if(expr.type == OP_PRE_INCREMENT || expr.type == OP_POST_INCREMENT || expr.type == OP_PRE_DECREMENT || expr.type == OP_POST_DECREMENT) {
		this.type_check_inc_decrement(expr);
	}
	else {
		eputsln("Unreachable - type_check_expr");
		exit(1);
	}
}

function Parser.type_check_array_init(array: Node*, arrayType: Type*) {
	if(arrayType.arrayLength < array.block.children.size) {
		array.print_position();
		eputs("Cannot initialize array of length '"); eputd(arrayType.arrayLength); eputs("' with '"); eputd(array.block.children.size);
		eputsln("' items");
		exit(1);
	}

	var declItemType = copy_type(arrayType);
	declItemType.indirection = declItemType.indirection - 1;

	for(var i = 0; i < array.block.children.size; ++i) {
		this.type_check_expr(array.block.children.at(i));

		var item: Type* = tc_typeStack.pop();

		if(!item.assignable(declItemType)) {
			(array.block.children.at(i) as Node*).print_position();
			eputs("Cannot initialize array of type "); eputs(type_to_string(declItemType)); eputs(" with item of type ");
			eputs(type_to_string(item)); eputln();
			exit(1);
		}
	}
	tc_typeStack.push(arrayType);
}

function Parser.type_check_define_var(stmt: Node*) {
	var declType = stmt.variable.type;
	resolve_type(declType);

	var name = stmt.variable.name;

	var redeclaration = this.lookup_same_scope_variable(&name);

	if(redeclaration != null) {
		stmt.print_position();
		eputs("Redeclaration of variable '"); name.eput(); eputsln("' in current scope");
		exit(1);
	}

	if(declType.type == DATA_TYPE_VOID && stmt.variable.value == null) {
		stmt.print_position();
		eputsln("Cannot infer type to variable without initial value");
		exit(1);
	}

	if(declType.type == DATA_TYPE_VOID) {
		this.type_check_expr(stmt.variable.value);
		stmt.variable.type = tc_typeStack.pop();
		declType = stmt.variable.type;
	}

	resolve_type(stmt.variable.type);

	stmt.variable.stackOffset = this.currentBlock.block.currentStackOffset += declType.size_offset();

	if(stmt.variable.stackOffset > this.currentFunction.funktion.localVariableStackOffset) {
		this.currentFunction.funktion.localVariableStackOffset = stmt.variable.stackOffset;
	}

	if(stmt.variable.value != null) {
		if(stmt.variable.value.type == AST_ARRAY_INIT) {
			this.type_check_array_init(stmt.variable.value, stmt.variable.type);
		}
		else {
			this.type_check_expr(stmt.variable.value);
		}

		var valueType: Type* = tc_typeStack.pop();
		resolve_type(valueType);

		if(!valueType.assignable(declType)) {
			stmt.print_position();
			eputs("Cannot assign type "); eputs(type_to_string(valueType)); eputs(" to variable expecting "); eputs(type_to_string(declType));
			eputln();
			exit(1);
		}
	}

	this.currentBlock.block.variables.push(stmt);
}

function Parser.type_check_if_statement(stmt: Node*) {
	this.type_check_expr(stmt.conditional.condition);

	var conditionType: Type* = tc_typeStack.pop();

	if(!conditionType.assignable(INT_TYPE)) {
		stmt.print_position();
		eputs("Expected condition to be type 'int' but got "); eputs(type_to_string(conditionType)); eputln();
		exit(1);
	}

	this.type_check_statement(stmt.conditional.doTrue);

	var trueHasReturned = this.currentBlock.block.hasReturned;
	var falseHasReturned = false;

	if(stmt.conditional.doFalse != null) {
		this.type_check_statement(stmt.conditional.doFalse);
		falseHasReturned = this.currentBlock.block.hasReturned;
	}

	this.currentBlock.block.hasReturned = trueHasReturned && falseHasReturned;
}

function Parser.type_check_while_statement(stmt: Node*) {
	var wasCheckingLoop = tc_checkingLoop;
	tc_checkingLoop = true;

	this.type_check_expr(stmt.conditional.condition);

	var conditionType: Type* = tc_typeStack.pop();

	if(!conditionType.assignable(INT_TYPE)) {
		stmt.print_position();
		eputs("Expected condition to be type 'int' but got "); eputs(type_to_string(conditionType)); eputln();
		exit(1);
	}

	this.type_check_statement(stmt.conditional.doTrue);

	tc_checkingLoop = wasCheckingLoop;
}

function Parser.type_check_for_statement(stmt: Node*) {
	var wasCheckingLoop = tc_checkingLoop;
	tc_checkingLoop = true;

	if(stmt.loop.initial != null) this.type_check_statement(stmt.loop.initial);
	if(stmt.loop.condition != null) {
		this.type_check_expr(stmt.loop.condition);
		var conditionType: Type* = tc_typeStack.pop();

		if(!conditionType.assignable(INT_TYPE)) {
			stmt.print_position();
			eputs("Expected condition to be type 'int' but got "); eputs(type_to_string(conditionType)); eputln();
			exit(1);
		}
	}
	if(stmt.loop.iteration != null) {
		this.type_check_expr(stmt.loop.iteration);
		tc_typeStack.pop();
	}

	this.type_check_statement(stmt.loop.body);

	tc_checkingLoop = wasCheckingLoop;
}

function Parser.type_check_when_statement(stmt: Node*) {
	this.type_check_expr(stmt.vhen.match);
	var match: Type* = tc_typeStack.pop();
	resolve_type(match);

	if(!match.assignable(INT_TYPE)) {
		stmt.vhen.match.print_position();
		eputsln("Expected when match clause to be type 'int'");
		exit(1);
	}

	var hasReturned = true;
	for(var i = 0; i < stmt.vhen.branches.size; ++i) {
		var branch: Node* = stmt.vhen.branches.at(i);

		// branch.branch.values are guaranteed to be an integer as they are a constant

		this.type_check_statement(branch.branch.body);
		hasReturned = hasReturned && this.currentBlock.block.hasReturned;
	}

	if(stmt.vhen.default != null) {
		this.type_check_statement(stmt.vhen.default);
		hasReturned = hasReturned && this.currentBlock.block.hasReturned;
	}
	else {
		hasReturned = false;
	}

	this.currentBlock.block.hasReturned = hasReturned;
}

function Parser.type_check_statement(stmt: Node*) {
	if(stmt.type == AST_IF) {
		this.type_check_if_statement(stmt);
	}
	else if(stmt.type == AST_WHILE) {
		this.type_check_while_statement(stmt);
	}
	else if(stmt.type == AST_FOR) {
		this.type_check_for_statement(stmt);
	}
	else if(stmt.type == AST_WHEN) {
		this.type_check_when_statement(stmt);
	}
	else if(stmt.type == AST_RETURN) {
		var returnType: Type*;
		if(stmt.unary != null) {
			this.type_check_expr(stmt.unary);
			returnType = tc_typeStack.pop();
		}
		else {
			returnType = VOID_TYPE;
		}

		var expectedType = this.currentFunction.funktion.returnType;
		if(!returnType.assignable(expectedType)) {
			stmt.print_position();
			eputs("Cannot return type "); eputs(type_to_string(returnType)); eputs(" from function expecting "); eputs(type_to_string(expectedType));
			eputln();
			exit(1);
		}
		this.currentBlock.block.hasReturned = true;
	}
	else if(stmt.type == AST_DEFINE_VAR) {
		this.type_check_define_var(stmt);
	}
	else if(stmt.type == AST_EXPR_STMT) {
		this.type_check_expr(stmt.unary);
	}
	else if(stmt.type == AST_BLOCK) {
		this.type_check_block(stmt);
		this.currentBlock.block.hasReturned = stmt.block.hasReturned;
	}
	else if(stmt.type == AST_CONTINUE) {
		if(!tc_checkingLoop) {
			stmt.print_position();
			eputsln("Cannot use 'continue' outside of a loop");
			exit(1);
		}
	}
	else if(stmt.type == AST_BREAK) {
		if(!tc_checkingLoop) {
			stmt.print_position();
			eputsln("Cannot use 'break' outside of a loop");
			exit(1);
		}
	}
	else {
		eputsln("Unreachable - type_check_statement");
		exit(1);
	}
}

function Parser.type_check_block(block: Node*) {
	block.block.variables = new_vector();
	block.block.currentStackOffset = this.currentBlock.block.currentStackOffset;
	this.currentBlock = block;

	for(var i = 0; i < block.block.children.size; ++i) {
		if(block.block.hasReturned) {
			(block.block.children.at(i) as Node*).print_position();
			eputsln("Unreachable code (all paths return)");
			exit(1);
		}
		this.type_check_statement(block.block.children.at(i));
	}

	this.currentBlock = block.block.parent;
}

function Parser.type_check_function(funktion: Node*) {
	var stackOffset = 0;

	for(var i = 0; i < funktion.funktion.arguments.size; ++i) {
		var arg: Node* = funktion.funktion.arguments.at(i);

		if(arg.variable.type.isArray) {
			arg.print_position();
			eputsln("Arrays cannot be used as function arguments - consider using a pointer instead");
			exit(1);
		}
		else if(arg.variable.type.is_structural()) {
			arg.print_position();
			eputsln("Structs cannot be used as function arguments - consider using a pointer instead");
			exit(1);
		}

		//FIXME Have the correct qualifiers and registers used in codegen.zpr for arguments
		stackOffset += ceil_multiple(arg.variable.type.size(), 8);

		arg.variable.stackOffset = stackOffset;
	}

	if(funktion.funktion.returnType.isArray) {
		funktion.print_position();
		eputsln("Arrays cannot be used as function return types - consider using a pointer instead");
		exit(1);
	}
	else if(funktion.funktion.returnType.is_structural()) {
		funktion.print_position();
		eputsln("Structs cannot be used as function return types - consider using a pointer instead");
		exit(1);
	}

	funktion.funktion.body.block.currentStackOffset = stackOffset;
	funktion.funktion.localVariableStackOffset = stackOffset;

	this.currentFunction = funktion;

	this.currentBlock = funktion.funktion.body;
	this.type_check_block(funktion.funktion.body);

	if(!funktion.funktion.body.block.hasReturned) {
		if(funktion.funktion.returnType.is_void()) {
			var tok = synthetic_token(TOKEN_RETURN, "return");
			var implReturn = new_node(AST_RETURN, tok);
			funktion.funktion.body.add_child(implReturn);
		}
		else {
			funktion.print_position();
			eputs("A non-void returning function must return a value (returning "); eputs(type_to_string(funktion.funktion.returnType));
			eputsln(")");
			exit(1);
		}
	}
}

function Parser.type_check_global_var(stmt: Node*) {
	var declType = stmt.variable.type;
	resolve_type(declType);
	var name = stmt.variable.name;

	var redeclaration = this.lookup_global_variable(&name);

	if(redeclaration != null) {
		stmt.print_position();
		eputs("Redeclaration of variable '"); name.eput(); eputsln("' in current scope");
		exit(1);
	}

	if(declType.type == DATA_TYPE_VOID && stmt.variable.value == null) {
		stmt.print_position();
		eputsln("Cannot infer type to variable without initial value");
		exit(1);
	}

	if(declType.type == DATA_TYPE_VOID) {
		this.type_check_expr(stmt.variable.value);
		stmt.variable.type = tc_typeStack.pop();
		declType = stmt.variable.type;
	}

	resolve_type(stmt.variable.type);

	if(stmt.variable.value != null) {
		if(stmt.variable.value.type == AST_ARRAY_INIT) {
			this.type_check_array_init(stmt.variable.value, stmt.variable.type);
		}
		else {
			this.type_check_expr(stmt.variable.value);
		}

		var valueType: Type* = tc_typeStack.pop();
		resolve_type(valueType);

		if(!valueType.assignable(declType)) {
			stmt.print_position();
			eputs("Cannot assign type "); eputs(type_to_string(valueType)); eputs(" to variable expecting "); eputs(type_to_string(declType));
			eputln();
			exit(1);
		}
	}

	this.globalVars.push(stmt);
}

function add_offsets_to_union(unionType: Type*) {
	if(unionType.built) return;
	unionType.built = true;

	for(var i = 0; i < unionType.fields.size; ++i) {
		var field: Node* = unionType.fields.at(i);
		var type = field.variable.type;

		if((type.type == DATA_TYPE_UNRESOLVED || type.type == DATA_TYPE_UNION) && type.name.equals(&unionType.name) && type.indirection == 0) {
			field.print_position();
			eputsln("A union cannot contain a member of itself (use a pointer instead)");
			exit(1);
		}

		field.variable.stackOffset = 0;

		resolve_type(type);
		resolve_type(field.variable.type);

		if(type.type == DATA_TYPE_STRUCT) {
			add_offsets_to_struct(type);
		}
		else if(type.type == DATA_TYPE_UNION) {
			add_offsets_to_union(type);
		}
	}
}

function add_offsets_to_struct(structType: Type*) {
	if(structType.built) return;
	structType.built = true;

	var offset = 0;

	for(var i = 0; i < structType.fields.size; ++i) {
		var field: Node* = structType.fields.at(i);
		var type = field.variable.type;

		if((type.type == DATA_TYPE_UNRESOLVED || type.type == DATA_TYPE_STRUCT) && type.name.equals(&structType.name) && type.indirection == 0) {
			field.print_position();
			eputsln("A struct cannot contain a member of itself (use a pointer instead)");
			exit(1);
		}

		resolve_type(type);
		resolve_type(field.variable.type);
		
		field.variable.stackOffset = offset;

		if(!field.variable.unionField)
			offset += field.variable.type.size_offset();

		if(type.type == DATA_TYPE_STRUCT) {
			add_offsets_to_struct(type);
		}
		else if(type.type == DATA_TYPE_UNION) {
			add_offsets_to_union(type);
		}
	}
}

function Parser.type_check(program: Node*) {
	tc_definedTypes = this.definedTypes;

	var mainTok = synthetic_token(TOKEN_IDENTIFIER, "main");
	var mainName: Name;
	this.bind_name(&mainName, mainTok);

	for(var i = 0; i < program.block.children.size; ++i) {
		var node: Node* = program.block.children.at(i);

		if(node.type == AST_FUNCTION) {
			if(!node.funktion.hasImplicitBody)
				this.type_check_function(node);

			if(node.funktion.name.equals(&mainName)) {
				node.funktion.used = true;
			}
		}
		else if(node.type == AST_DEFINE_GLOBAL_VAR) {
			this.type_check_global_var(node);
		}
		else if(node.type == AST_DEFINE_CONST) {
			// Do nothing - parser verifies that this is an integer
		}
		else if(node.type == AST_ENUM) {
			// Do nothing - parser verifies that all fields are integers
		}
		else if(node.type == AST_STRUCT) {
			add_offsets_to_struct(node.computedType);
		}
		else if(node.type == AST_UNION) {
			add_offsets_to_union(node.computedType);
		}
		else {
			eputsln("Unreachable - unhandled node type in type_check (program)");
			exit(1);
		}
	}
}