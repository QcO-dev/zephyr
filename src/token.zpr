import "std/core.zpr";
import "std/string.zpr";

// Updating this list requires updating token_type_to_string
enum TokenType {
	TOKEN_LEFT_PAREN,
	TOKEN_RIGHT_PAREN,
	TOKEN_LEFT_BRACE,
	TOKEN_RIGHT_BRACE,
	TOKEN_LEFT_SQBR,
	TOKEN_RIGHT_SQBR,
	TOKEN_COLON,
	TOKEN_SEMICOLON,
	TOKEN_COMMA,
	TOKEN_DOT,
	TOKEN_QUESTION,
	TOKEN_TILDE,
	TOKEN_MINUS,
	TOKEN_BANG,
	TOKEN_PLUS,
	TOKEN_STAR,
	TOKEN_SLASH,
	TOKEN_PERCENT,
	TOKEN_AMP,
	TOKEN_AMP_AMP,
	TOKEN_BAR,
	TOKEN_BAR_BAR,
	TOKEN_XOR,
	TOKEN_LESS,
	TOKEN_LSH,
	TOKEN_GREATER,
	TOKEN_RSH,
	TOKEN_EQ,
	TOKEN_EQEQ,
	TOKEN_BANG_EQ,
	TOKEN_LEQ,
	TOKEN_GEQ,
	TOKEN_ARROW,
	
	TOKEN_INCREMENT,
	TOKEN_DECREMENT,

	TOKEN_MINUS_EQ,
	TOKEN_PLUS_EQ,
	TOKEN_STAR_EQ,
	TOKEN_SLASH_EQ,
	TOKEN_PERCENT_EQ,
	TOKEN_AMP_EQ,
	TOKEN_BAR_EQ,
	TOKEN_XOR_EQ,
	TOKEN_LSH_EQ,
	TOKEN_RSH_EQ,

	TOKEN_INT_LITERAL,
	TOKEN_CHAR_LITERAL,
	TOKEN_STRING,
	TOKEN_IDENTIFIER,

	TOKEN_ALIAS,
	TOKEN_AS,
	TOKEN_ANY,
	TOKEN_BREAK,
	TOKEN_CONST,
	TOKEN_CONTINUE,
	TOKEN_ELSE,
	TOKEN_ENUM,
	TOKEN_IF,
	TOKEN_IMPORT,
	TOKEN_INT,
	TOKEN_I8,
	TOKEN_I16,
	TOKEN_I32,
	TOKEN_I64,
	TOKEN_FOR,
	TOKEN_FUNCTION,
	TOKEN_RETURN,
	TOKEN_SIZEOF,
	TOKEN_STRUCT,
	TOKEN_UNION,
	TOKEN_VAR,
	TOKEN_VOID,
	TOKEN_WHEN,
	TOKEN_WHILE,

	TOKEN_ERROR,
	TOKEN_EOF
}

struct Token {
	type: TokenType;
	start: i8*;
	length: int;
	line: int;
	filename: i8*;
}

function token_type_to_string(type: TokenType): i8* {
	when(type) {
		TOKEN_LEFT_PAREN -> return "left-paren";
		TOKEN_RIGHT_PAREN -> return "right-paren";
		TOKEN_LEFT_BRACE -> return "left-brace";
		TOKEN_RIGHT_BRACE -> return "right-brace";
		TOKEN_RIGHT_BRACE -> return "right-sqbr";
		TOKEN_RIGHT_BRACE -> return "right-sqbr";
		TOKEN_COLON -> return "colon";
		TOKEN_SEMICOLON -> return "semicolon";
		TOKEN_COMMA -> return "comma";
		TOKEN_DOT -> return "dot";
		TOKEN_QUESTION -> return "question";
		TOKEN_TILDE -> return "tilde";
		TOKEN_MINUS -> return "minus";
		TOKEN_BANG -> return "bang";
		TOKEN_PLUS -> return "plus";
		TOKEN_STAR -> return "star";
		TOKEN_SLASH -> return "slash";
		TOKEN_PERCENT -> return "percent";
		TOKEN_AMP -> return "amp";
		TOKEN_AMP_AMP -> return "amp-amp";
		TOKEN_BAR -> return "bar";
		TOKEN_BAR_BAR -> return "bar-bar";
		TOKEN_XOR -> return "xor";
		TOKEN_LESS -> return "less";
		TOKEN_LSH -> return "lsh";
		TOKEN_GREATER -> return "greater";
		TOKEN_RSH -> return "rsh";
		TOKEN_EQ -> return "=";
		TOKEN_EQEQ -> return "eq-eq";
		TOKEN_BANG_EQ -> return "bang-eq";
		TOKEN_LEQ -> return "leq";
		TOKEN_GEQ -> return "geq";
		TOKEN_ARROW -> return "arrow";

		TOKEN_MINUS_EQ -> return "-=";
		TOKEN_PLUS_EQ -> return "+=";
		TOKEN_STAR_EQ -> return "*=";
		TOKEN_SLASH_EQ -> return "/=";
		TOKEN_PERCENT_EQ -> return "%=";
		TOKEN_AMP_EQ -> return "&=";
		TOKEN_BAR_EQ -> return "|=";
		TOKEN_XOR_EQ -> return "^=";
		TOKEN_LSH_EQ -> return "<<=";
		TOKEN_RSH_EQ -> return ">>=";

		TOKEN_INT_LITERAL -> return "int-literal";
		TOKEN_CHAR_LITERAL -> return "char-literal";
		TOKEN_STRING -> return "string";
		TOKEN_IDENTIFIER -> return "identifier";

		TOKEN_ALIAS -> return "alias";
		TOKEN_AS -> return "as";
		TOKEN_ANY -> return "any";
		TOKEN_BREAK -> return "break";
		TOKEN_CONST -> return "const";
		TOKEN_CONTINUE -> return "continue";
		TOKEN_ELSE -> return "else";
		TOKEN_ELSE -> return "enum";
		TOKEN_IF -> return "if";
		TOKEN_IMPORT -> return "import";
		TOKEN_INT -> return "int";
		TOKEN_I8 -> return "i8";
		TOKEN_I16 -> return "i16";
		TOKEN_I32 -> return "i32";
		TOKEN_I64 -> return "i64";
		TOKEN_FOR -> return "for";
		TOKEN_FUNCTION -> return "function";
		TOKEN_RETURN -> return "return";
		TOKEN_SIZEOF -> return "sizeof";
		TOKEN_STRUCT -> return "struct";
		TOKEN_UNION -> return "union";
		TOKEN_VAR -> return "var";
		TOKEN_VOID -> return "void";
		TOKEN_WHEN -> return "when";
		TOKEN_WHILE -> return "while";

		TOKEN_ERROR -> return "error";
		TOKEN_EOF -> return "eof";
	}

	return "<unknown type>";
}

function put_token_string(token: Token*) {
	// A bit of a hack
	write(stdout, token.start, token.length);
}

function eput_token_string(token: Token*) {
	// A bit of a hack
	write(stderr, token.start, token.length);
}

function File.put_token_string(token: Token*) {
	this.write(token.start, token.length);
}

function print_token(token: Token*) {
	putd(token.line);
	puts(" ");
	puts(token_type_to_string(token.type));
	puts(" '");
	put_token_string(token);
	puts("'");
}

function Token.equals(b: Token*): bool {
	return this.length == b.length && memeq(this.start, b.start, this.length);
}

function synthetic_token(type: TokenType, value: i8*): Token* {
	var token: Token* = malloc(sizeof(Token));
	token.line = 0;
	token.type = type;
	token.start = value;
	token.length = strlen(value);
	return token;
}

function Token.name_to_str(): i8* {
	var name = malloc(this.length + 1);
	memcpy(name, this.start, this.length);
	name[this.length] = 0;
	return name;
}