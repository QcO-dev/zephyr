import "std/core.zpr";
import "std/string.zpr";

// Updating this list requires updating token_type_to_string
enum TokenType {
	TOKEN_LEFT_PAREN,
	TOKEN_RIGHT_PAREN,
	TOKEN_LEFT_BRACE,
	TOKEN_RIGHT_BRACE,
	TOKEN_LEFT_SQBR,
	TOKEN_RIGHT_SQBR,
	TOKEN_COLON,
	TOKEN_SEMICOLON,
	TOKEN_COMMA,
	TOKEN_DOT,
	TOKEN_QUESTION,
	TOKEN_TILDE,
	TOKEN_MINUS,
	TOKEN_BANG,
	TOKEN_PLUS,
	TOKEN_STAR,
	TOKEN_SLASH,
	TOKEN_PERCENT,
	TOKEN_AMP,
	TOKEN_AMP_AMP,
	TOKEN_BAR,
	TOKEN_BAR_BAR,
	TOKEN_XOR,
	TOKEN_LESS,
	TOKEN_LSH,
	TOKEN_GREATER,
	TOKEN_RSH,
	TOKEN_EQ,
	TOKEN_EQEQ,
	TOKEN_BANG_EQ,
	TOKEN_LEQ,
	TOKEN_GEQ,
	TOKEN_ARROW,
	
	TOKEN_INCREMENT,
	TOKEN_DECREMENT,

	TOKEN_MINUS_EQ,
	TOKEN_PLUS_EQ,
	TOKEN_STAR_EQ,
	TOKEN_SLASH_EQ,
	TOKEN_PERCENT_EQ,
	TOKEN_AMP_EQ,
	TOKEN_BAR_EQ,
	TOKEN_XOR_EQ,
	TOKEN_LSH_EQ,
	TOKEN_RSH_EQ,

	TOKEN_INT_LITERAL,
	TOKEN_CHAR_LITERAL,
	TOKEN_STRING,
	TOKEN_IDENTIFIER,

	TOKEN_AS,
	TOKEN_ANY,
	TOKEN_BREAK,
	TOKEN_CONST,
	TOKEN_CONTINUE,
	TOKEN_ELSE,
	TOKEN_ENUM,
	TOKEN_IF,
	TOKEN_IMPORT,
	TOKEN_INT,
	TOKEN_I8,
	TOKEN_I16,
	TOKEN_I32,
	TOKEN_I64,
	TOKEN_FOR,
	TOKEN_FUNCTION,
	TOKEN_RETURN,
	TOKEN_SIZEOF,
	TOKEN_STRUCT,
	TOKEN_UNION,
	TOKEN_VAR,
	TOKEN_VOID,
	TOKEN_WHEN,
	TOKEN_WHILE,

	TOKEN_ERROR,
	TOKEN_EOF
}

struct Token {
	type: int;
	start: i8*;
	length: int;
	line: int;
	filename: i8*;
}

function token_type_to_string(type: int): i8* {
	if(type == TOKEN_LEFT_PAREN) return "left-paren";
	if(type == TOKEN_RIGHT_PAREN) return "right-paren";
	if(type == TOKEN_LEFT_BRACE) return "left-brace";
	if(type == TOKEN_RIGHT_BRACE) return "right-brace";
	if(type == TOKEN_RIGHT_BRACE) return "right-sqbr";
	if(type == TOKEN_RIGHT_BRACE) return "right-sqbr";
	if(type == TOKEN_COLON) return "colon";
	if(type == TOKEN_SEMICOLON) return "semicolon";
	if(type == TOKEN_COMMA) return "comma";
	if(type == TOKEN_DOT) return "dot";
	if(type == TOKEN_QUESTION) return "question";
	if(type == TOKEN_TILDE) return "tilde";
	if(type == TOKEN_MINUS) return "minus";
	if(type == TOKEN_BANG) return "bang";
	if(type == TOKEN_PLUS) return "plus";
	if(type == TOKEN_STAR) return "star";
	if(type == TOKEN_SLASH) return "slash";
	if(type == TOKEN_PERCENT) return "percent";
	if(type == TOKEN_AMP) return "amp";
	if(type == TOKEN_AMP_AMP) return "amp-amp";
	if(type == TOKEN_BAR) return "bar";
	if(type == TOKEN_BAR_BAR) return "bar-bar";
	if(type == TOKEN_XOR) return "xor";
	if(type == TOKEN_LESS) return "less";
	if(type == TOKEN_LSH) return "lsh";
	if(type == TOKEN_GREATER) return "greater";
	if(type == TOKEN_RSH) return "rsh";
	if(type == TOKEN_EQ) return "=";
	if(type == TOKEN_EQEQ) return "eq-eq";
	if(type == TOKEN_BANG_EQ) return "bang-eq";
	if(type == TOKEN_LEQ) return "leq";
	if(type == TOKEN_GEQ) return "geq";
	if(type == TOKEN_ARROW) return "arrow";

	if(type == TOKEN_MINUS_EQ) return "-=";
	if(type == TOKEN_PLUS_EQ) return "+=";
	if(type == TOKEN_STAR_EQ) return "*=";
	if(type == TOKEN_SLASH_EQ) return "/=";
	if(type == TOKEN_PERCENT_EQ) return "%=";
	if(type == TOKEN_AMP_EQ) return "&=";
	if(type == TOKEN_BAR_EQ) return "|=";
	if(type == TOKEN_XOR_EQ) return "^=";
	if(type == TOKEN_LSH_EQ) return "<<=";
	if(type == TOKEN_RSH_EQ) return ">>=";

	if(type == TOKEN_INT_LITERAL) return "int-literal";
	if(type == TOKEN_CHAR_LITERAL) return "char-literal";
	if(type == TOKEN_STRING) return "string";
	if(type == TOKEN_IDENTIFIER) return "identifier";

	if(type == TOKEN_AS) return "as";
	if(type == TOKEN_ANY) return "any";
	if(type == TOKEN_BREAK) return "break";
	if(type == TOKEN_CONST) return "const";
	if(type == TOKEN_CONTINUE) return "continue";
	if(type == TOKEN_ELSE) return "else";
	if(type == TOKEN_ELSE) return "enum";
	if(type == TOKEN_IF) return "if";
	if(type == TOKEN_IMPORT) return "import";
	if(type == TOKEN_INT) return "int";
	if(type == TOKEN_I8) return "i8";
	if(type == TOKEN_I16) return "i16";
	if(type == TOKEN_I32) return "i32";
	if(type == TOKEN_I64) return "i64";
	if(type == TOKEN_FOR) return "for";
	if(type == TOKEN_FUNCTION) return "function";
	if(type == TOKEN_RETURN) return "return";
	if(type == TOKEN_SIZEOF) return "sizeof";
	if(type == TOKEN_STRUCT) return "struct";
	if(type == TOKEN_UNION) return "union";
	if(type == TOKEN_VAR) return "var";
	if(type == TOKEN_VOID) return "void";
	if(type == TOKEN_WHEN) return "when";
	if(type == TOKEN_WHILE) return "while";

	if(type == TOKEN_ERROR) return "error";
	if(type == TOKEN_EOF) return "eof";

	return "<unknown type>";
}

function put_token_string(token: Token*) {
	// A bit of a hack
	write(stdout, token.start, token.length);
}

function eput_token_string(token: Token*) {
	// A bit of a hack
	write(stderr, token.start, token.length);
}

function File.put_token_string(token: Token*) {
	this.write(token.start, token.length);
}

function print_token(token: Token*) {
	putd(token.line);
	puts(" ");
	puts(token_type_to_string(token.type));
	puts(" '");
	put_token_string(token);
	puts("'");
}

function Token.equals(b: Token*): int {
	return this.length == b.length && memeq(this.start, b.start, this.length);
}

function synthetic_token(type: int, value: i8*): Token* {
	var token: Token* = malloc(sizeof(Token));
	token.line = 0;
	token.type = type;
	token.start = value;
	token.length = strlen(value);
	return token;
}