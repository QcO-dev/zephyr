import "std/vector.zpr";

// Updating this list requires updating node_type_to_string and print_ast_depth
enum NodeType {
	OP_BWNOT,
	OP_NEG,
	OP_NOT,
	OP_ADD,
	OP_SUB,
	OP_MUL,
	OP_DIV,
	OP_MOD,
	OP_BWAND,
	OP_BWOR,
	OP_XOR,
	OP_LSH,
	OP_RSH,
	OP_EQUAL,
	OP_NOT_EQUAL,
	OP_LESS,
	OP_LESS_EQ,
	OP_GREATER,
	OP_GREATER_EQ,
	OP_AND,
	OP_OR,
	OP_TERNARY,
	OP_ADDROF,
	OP_DEREF,
	OP_SIZEOF,
	OP_ACCESS_SUBSCRIPT,
	OP_ACCESS_MEMBER,
	OP_ASSIGN,
	OP_PRE_INCREMENT,
	OP_PRE_DECREMENT,
	OP_POST_INCREMENT,
	OP_POST_DECREMENT,

	AST_RELATIVE,
	AST_INT_LITERAL,
	AST_CHAR_LITERAL,
	AST_STRING,
	AST_CALL,
	AST_CALL_METHOD,
	AST_DEFINE_CONST,
	AST_DEFINE_VAR,
	AST_ACCESS_VAR,
	AST_DEFINE_GLOBAL_VAR,
	AST_ACCESS_GLOBAL_VAR,
	AST_ARRAY_INIT,
	AST_EXPR_STMT,
	AST_IF,
	AST_WHILE,
	AST_FOR,
	AST_CAST,
	AST_STRUCT,
	AST_UNION,
	AST_ENUM,
	AST_MEMBER,
	AST_CONTINUE,
	AST_BREAK,
	AST_RETURN,
	AST_FUNCTION,
	AST_BLOCK,
	AST_PROGRAM
}

// Updating this list requires updating data_type_to_string
enum DataType {
	DATA_TYPE_VOID,
	DATA_TYPE_INT,
	DATA_TYPE_I8,
	DATA_TYPE_I16,
	DATA_TYPE_I32,
	DATA_TYPE_I64,
	DATA_TYPE_ANY,
	DATA_TYPE_STRUCT,
	DATA_TYPE_UNION,
	DATA_TYPE_UNRESOLVED
}

struct Type {
	type: int; // DataType
	indirection: int;
	isArray: int;
	arrayLength: int;

	name: Token*;
	fields: Vector*;
	methods: Vector*;

	built: int;
}

enum LValue {
	LVALUE_NONE,
	LVALUE_LOCAL,
	LVALUE_GLOBAL,
	LVALUE_SUBSCRIPT,
	LVALUE_DEREF,
	LVALUE_MEMBER
}

struct Node {
	type: int; // NodeType
	position: Token*;
	lvalue: int;
	computedType: Type*;

	union {
		unary: Node*;

		binary: struct {
			lhs: Node*;
			rhs: Node*;
		};

		ternary: struct {
			lhs: Node*;
			mid: Node*;
			rhs: Node*;
		};

		conditional: struct {
			condition: Node*;
			doTrue: Node*;
			doFalse: Node*;
		};

		loop: struct {
			initial: Node*;
			condition: Node*;
			iteration: Node*;
			body: Node*;
		};

		funktion: struct {
			name: Token*;
			returnType: Type*;
			body: Node*;
			hasImplicitBody: int;

			isMethod: int;
			parent: Node*;
			parentType: Type*;

			arguments: Vector*;

			localVariableStackOffset: int;

			used: int;
		};

		block: struct {
			children: Vector*;

			hasReturned: int;

			parent: Node*;
			variables: Vector*;
			currentStackOffset: int;
		};

		literal: struct {
			type: Type*;

			az: union {
				integer: int;
				string: struct {
					chars: i8*;
					length: int;
					id: int;
				};
			};
		};

		variable: struct {
			name: Token*;
			type: Type*;
			value: Node*;

			stackOffset: int;
			unionField: int;
		};

		constant: struct {
			name: Token*;
			value: int;
		};

		member: struct {
			name: Token*;
			parent: Node*;
			value: Node*;
			memberRef: Node*;
		};

		assignment: struct {
			lhs: Node*;
			rhs: Node*;
			op: Token*;
		};
	};
}

function data_type_to_string(type: int): i8* {
	if(type == DATA_TYPE_VOID) return "void";
	if(type == DATA_TYPE_INT) return "int";
	if(type == DATA_TYPE_I8) return "i8";
	if(type == DATA_TYPE_I16) return "i16";
	if(type == DATA_TYPE_I32) return "i32";
	if(type == DATA_TYPE_I64) return "i64";
	if(type == DATA_TYPE_ANY) return "any";
	if(type == DATA_TYPE_UNRESOLVED || type == DATA_TYPE_STRUCT || type == DATA_TYPE_UNION) {
		eputsln("Unreachable - data_type_to_string");
		return null;
	}

	return "<unknown type>";
}

function struct_name_string(strukt: Type*): i8* {
	var str = malloc(strukt.name.length + 1);
	memcpy(str, strukt.name.start, strukt.name.length);
	str[strukt.name.length] = 0;
	return str;
}

function type_to_string(type: Type*): i8* {
	var baseType: i8*;

	if(type.type == DATA_TYPE_STRUCT || type.type == DATA_TYPE_UNION || type.type == DATA_TYPE_UNRESOLVED) {
		baseType = struct_name_string(type);
	}
	else {
		baseType = data_type_to_string(type.type);
	}

	var str: i8* = malloc(strlen(baseType) + type.indirection + 1);
	strcpy(str, baseType);

	for(var i = 0; i < type.indirection; ++i) {
		strcat(str, "*");
	}
	return str;
}

function node_type_to_string(type: int): i8* {
	if(type == OP_BWNOT) return "~";
	if(type == OP_NEG) return "-";
	if(type == OP_NOT) return "!";
	if(type == OP_ADD) return "+";
	if(type == OP_SUB) return "-";
	if(type == OP_MUL) return "*";
	if(type == OP_DIV) return "/";
	if(type == OP_MOD) return "%";
	if(type == OP_BWAND) return "&";
	if(type == OP_BWOR) return "|";
	if(type == OP_XOR) return "^";
	if(type == OP_LSH) return "<<";
	if(type == OP_RSH) return ">>";
	if(type == OP_EQUAL) return "==";
	if(type == OP_NOT_EQUAL) return "!=";
	if(type == OP_LESS) return "<";
	if(type == OP_LESS_EQ) return "<=";
	if(type == OP_GREATER) return ">";
	if(type == OP_GREATER_EQ) return ">=";
	if(type == OP_AND) return "&&";
	if(type == OP_OR) return "||";
	if(type == OP_TERNARY) return "?";
	if(type == OP_ADDROF) return "&";
	if(type == OP_DEREF) return "*";
	if(type == OP_SIZEOF) return "sizeof";
	if(type == OP_ACCESS_SUBSCRIPT) return "[";
	if(type == OP_PRE_INCREMENT) return "++";
	if(type == OP_PRE_DECREMENT) return "--";
	if(type == OP_POST_INCREMENT) return "++";
	if(type == OP_POST_DECREMENT) return "--";
	if(type == AST_INT_LITERAL) return "int literal";
	if(type == AST_CHAR_LITERAL) return "char literal";
	if(type == AST_STRING) return "string";
	if(type == AST_CALL) return "call";
	if(type == AST_CALL_METHOD) return "call method";
	if(type == AST_DEFINE_CONST) return "define const";
	if(type == AST_DEFINE_VAR) return "define var";
	if(type == AST_ACCESS_VAR) return "access var";
	if(type == AST_DEFINE_GLOBAL_VAR) return "define gvar";
	if(type == AST_ACCESS_GLOBAL_VAR) return "access gvar";
	if(type == AST_ARRAY_INIT) return "init array";
	if(type == AST_EXPR_STMT) return "expr stmt";
	if(type == AST_IF) return "if";
	if(type == AST_WHILE) return "while";
	if(type == AST_FOR) return "for";
	if(type == AST_CAST) return "cast";
	if(type == AST_STRUCT) return "struct";
	if(type == AST_UNION) return "union";
	if(type == AST_ENUM) return "enum";
	if(type == AST_MEMBER) return "member";
	if(type == AST_CONTINUE) return "continue";
	if(type == AST_BREAK) return "break";
	if(type == AST_RETURN) return "return";
	if(type == AST_FUNCTION) return "function";
	if(type == AST_BLOCK) return "block";
	if(type == AST_PROGRAM) return "program";

	return "<unknown node type>";
}

function is_unary_op(type: int): int {
	return (
		type == OP_BWNOT ||
		type == OP_NEG ||
		type == OP_NOT ||
		type == OP_ADDROF ||
		type == OP_DEREF
	);
}

function is_binary_op(type: int): int {
	return (
		type == OP_ADD ||
		type == OP_SUB ||
		type == OP_MUL ||
		type == OP_DIV ||
		type == OP_MOD ||
		type == OP_BWAND ||
		type == OP_BWOR ||
		type == OP_XOR ||
		type == OP_LSH ||
		type == OP_RSH ||
		type == OP_EQUAL ||
		type == OP_NOT_EQUAL ||
		type == OP_LESS ||
		type == OP_LESS_EQ ||
		type == OP_GREATER ||
		type == OP_GREATER_EQ ||
		type == OP_OR ||
		type == OP_AND
	);
}

function print_ast_depth(node: Node*, depth: int) {
	for(var i = 0; i < depth; ++i) puts("  ");

	if(is_unary_op(node.type)) {
		putsln(node_type_to_string(node.type));
		print_ast_depth(node.unary, depth + 1);
	}
	else if(is_binary_op(node.type)) {
		putsln(node_type_to_string(node.type));
		print_ast_depth(node.binary.lhs, depth + 1);
		putln();
		print_ast_depth(node.binary.rhs, depth + 1);
	}
	else if(node.type == AST_PROGRAM) {
		for(var i = 0; i < node.block.children.size; ++i)
			print_ast_depth(node.block.children.at(i), depth);
	}
	else if(node.type == AST_BLOCK) {
		putsln("{");
		for(var i = 0; i < node.block.children.size; ++i)
			print_ast_depth(node.block.children.at(i), depth + 1);
		for(var i = 0; i < depth; ++i) puts("  ");
		putsln("}");
	}
	else if(node.type == AST_FUNCTION) {
		puts("function "); put_token_string(node.funktion.name); puts(": "); putsln(type_to_string(node.funktion.returnType));
		for(var i = 0; i < node.funktion.arguments.size; ++i) {
			var arg: Node* = node.funktion.arguments.at(i);
			puts("("); put_token_string(arg.variable.name); puts(": "); puts(type_to_string(arg.variable.type)); puts(") ");
		}
		if(node.funktion.arguments.size > 0) putln();
		if(!node.funktion.hasImplicitBody)
			print_ast_depth(node.funktion.body, depth);
	}
	else if(node.type == AST_CALL) {
		puts("call "); put_token_string(node.funktion.name); putln();
		for(var i = 0; i < node.funktion.arguments.size; ++i) {
			var arg: Node* = node.funktion.arguments.at(i);
			print_ast_depth(arg, depth + 1);
			if(i != node.funktion.arguments.size -1 ) putln();
		}
	}
	else if(node.type == AST_CALL_METHOD) {
		puts("call "); put_token_string(node.funktion.name); putln();
		for(var i = 0; i < node.funktion.arguments.size; ++i) {
			var arg: Node* = node.funktion.arguments.at(i);
			print_ast_depth(arg, depth + 1);
			if(i != node.funktion.arguments.size -1 ) putln();
		}

		for(var i = 0; i < depth; ++i) puts("  ");
		putsln("of");
		print_ast_depth(node.funktion.parent, depth + 1);
	}
	else if(node.type == AST_EXPR_STMT) {
		putsln("pop");
		print_ast_depth(node.unary, depth + 1);
		putln();
	}
	else if(node.type == AST_IF) {
		putsln("if");
		print_ast_depth(node.conditional.condition, depth + 1);
		putln();
		print_ast_depth(node.conditional.doTrue, depth + 1);
		putln();

		if(node.conditional.doFalse != null) {
			for(var i = 0; i < depth; ++i) puts("  ");
			putsln("else");
			print_ast_depth(node.conditional.doFalse, depth + 1);
			putln();
		}
	}
	else if(node.type == AST_WHILE) {
		putsln("while");
		print_ast_depth(node.conditional.condition, depth + 1);
		putln();
		print_ast_depth(node.conditional.doTrue, depth + 1);
		putln();
	}
	else if(node.type == AST_FOR) {
		putsln("for");
		if(node.loop.initial != null)
			print_ast_depth(node.loop.initial, depth + 1);
		else {
			for(var i = 0; i < depth; ++i) puts("  ");
			putsln("(no initializer)");
		}

		if(node.loop.condition != null) {
			print_ast_depth(node.loop.condition, depth + 1);
			putln();
		} else {
			for(var i = 0; i < depth; ++i) puts("  ");
			putsln("(no condition)");
		}

		if(node.loop.iteration != null) {
			print_ast_depth(node.loop.iteration, depth + 1);
			putln();
		} else {
			for(var i = 0; i < depth; ++i) puts("  ");
			putsln("(no iteration)");
		}

		print_ast_depth(node.loop.body, depth + 1);
		putln();
	}
	else if(node.type == AST_RETURN) {
		putsln("return");
		if(node.unary != null) {
			print_ast_depth(node.unary, depth + 1);
		}
		else {
			for(var i = 0; i < depth + 1; ++i) puts("  ");
			puts("(void)");
		}
		putln();
	}
	else if(node.type == AST_DEFINE_CONST) {
		puts("const "); put_token_string(node.constant.name); puts(" = "); putd(node.constant.value); putln();
	}
	else if(node.type == AST_DEFINE_VAR || node.type == AST_DEFINE_GLOBAL_VAR) {
		puts("var "); put_token_string(node.variable.name); puts(": "); putsln(type_to_string(node.variable.type));
		if(node.variable.value != null) {
			print_ast_depth(node.variable.value, depth + 1);
			putln();
		}
	}
	else if(node.type == AST_ACCESS_VAR || node.type == AST_ACCESS_GLOBAL_VAR) {
		puts("(var "); put_token_string(node.variable.name); puts(")");
	}
	else if(node.type == AST_INT_LITERAL) {
		puts("(literal "); putd(node.literal.az.integer); puts(")");
	}
	else if(node.type == AST_CHAR_LITERAL) {
		puts("(literal "); putc(node.literal.az.integer); puts(")");
	}
	else if(node.type == AST_STRING) {
		puts("(literal "); puts(node.literal.az.string.chars); puts(")");
	}
	else if(node.type == OP_TERNARY) {
		putsln("?");
		print_ast_depth(node.conditional.condition, depth + 1);
		putln();
		print_ast_depth(node.conditional.doTrue, depth + 1);
		putsln(":");
		print_ast_depth(node.conditional.doFalse, depth + 1);
	}
	else if(node.type == OP_SIZEOF) {
		puts("sizeof("); puts(type_to_string(node.computedType)); puts(")");
	}
	else if(node.type == OP_ACCESS_SUBSCRIPT) {
		putsln("subscript [");
		print_ast_depth(node.binary.lhs, depth + 1);
		putln();
		print_ast_depth(node.binary.rhs, depth + 1);
		putln();
		for(var i = 0; i < depth; ++i) puts("  ");
		puts("]");
	}
	else if(node.type == AST_ARRAY_INIT) {
		putsln("[");
		for(var i = 0; i < node.block.children.size; ++i) {
			print_ast_depth(node.block.children.at(i), depth + 1);
			putln();
		}
		for(var i = 0; i < depth; ++i) puts("  ");
		puts("]");
	}
	else if(node.type == OP_DEREF) {
		putsln("*");
		print_ast_depth(node.unary, depth + 1);
	}
	else if(node.type == AST_CAST) {
		putsln("cast");
		print_ast_depth(node.unary, depth + 1);
		putln();
		for(var i = 0; i < depth; ++i) puts("  ");
		puts("as "); puts(type_to_string(node.computedType));
	}
	else if(node.type == AST_STRUCT) {
		puts("struct "); put_token_string(node.variable.name); putln();
		for(var i = 0; i < node.computedType.fields.size; ++i) {
			print_ast_depth(node.computedType.fields.at(i), depth + 1);
		}
	}
	else if(node.type == AST_UNION) {
		puts("union "); put_token_string(node.variable.name); putln();
		for(var i = 0; i < node.computedType.fields.size; ++i) {
			print_ast_depth(node.computedType.fields.at(i), depth + 1);
		}
	}
	else if(node.type == AST_ENUM) {
		putsln("enum");
		for(var i = 0; i < node.block.children.size; ++i) {
			print_ast_depth(node.block.children.at(i), depth + 1);
		}
	}
	else if(node.type == AST_MEMBER) {
		put_token_string(node.variable.name); puts(": "); putsln(type_to_string(node.variable.type));
	}
	else if(node.type == OP_ACCESS_MEMBER) {
		puts("."); put_token_string(node.member.name); putln();
		print_ast_depth(node.member.parent, depth + 1);
	}
	else if(node.type == AST_CONTINUE) {
		putsln("continue");
	}
	else if(node.type == AST_BREAK) {
		putsln("break");
	}
	else if(node.type == OP_ASSIGN) {
		putsln(token_type_to_string(node.assignment.op.type));
		print_ast_depth(node.assignment.lhs, depth);
		print_ast_depth(node.assignment.rhs, depth + 1);
	}
	else if(node.type == OP_PRE_INCREMENT) {
		putsln("pre++");
		print_ast_depth(node.unary, depth + 1);
	}
	else if(node.type == OP_PRE_DECREMENT) {
		putsln("pre--");
		print_ast_depth(node.unary, depth + 1);
	}
	else if(node.type == OP_POST_INCREMENT) {
		putsln("post++");
		print_ast_depth(node.unary, depth + 1);
	}
	else if(node.type == OP_POST_DECREMENT) {
		putsln("post--");
		print_ast_depth(node.unary, depth + 1);
	}
	else {
		eputs("Cannot handle type in print_ast_depth - "); eputsln(node_type_to_string(node.type));
	}
}

function print_ast(ast: Node*) {
	print_ast_depth(ast, 0);
}
