import "std/core.zpr";
import "std/io.zpr";
import "zpr/ast.zpr";

var cg_ARG_REGISTERS: i8*[6] = [ "rdi", "rsi", "rdx", "rcx", "r8", "r9" ];
var cg_lableCount = 0;

function ceil_multiple(num: int, n: int): int {
	return ((num + n - 1) / n) * n;
}

function cmp_suffix(type: int): i8* {
	if(type == OP_EQUAL) return "e";
	if(type == OP_NOT_EQUAL) return "ne";
	if(type == OP_LESS) return "l";
	if(type == OP_LESS_EQ) return "le";
	if(type == OP_GREATER) return "g";
	if(type == OP_GREATER_EQ) return "ge";

	eputs("Unsupported type in generate_unary_rax - "); eputs(node_type_to_string(type)); eputln();
	exit(1);
	return null;
}

function generate_unary_rax(expr: Node*, out: File*) {
	if(expr.type == OP_BWNOT) {
		generate_expr_rax(expr.v.unary, out);
		out.putsln("    not rax");
	}
	else if(expr.type == OP_NEG) {
		generate_expr_rax(expr.v.unary, out);
		out.putsln("    neg rax");
	}
	else if(expr.type == OP_NOT) {
		generate_expr_rax(expr.v.unary, out);
		out.putsln("    test rax, rax");
		out.putsln("    sete al");
		out.putsln("    movzx rax, al");
	}
	else {
		eputs("Unsupported type in generate_unary_rax - "); eputs(node_type_to_string(expr.type)); eputln();
		exit(1);
	}
}

function generate_binary_rax(expr: Node*, out: File*) {
	generate_expr_rax(expr.v.binary.lhs, out);
	out.putsln("    push rax");
	generate_expr_rax(expr.v.binary.rhs, out);
	out.putsln("    mov rcx, rax");
	out.putsln("    pop rax");

	if(expr.type == OP_ADD) {
		out.putsln("    add rax, rcx");
	}
	else if(expr.type == OP_SUB) {
		out.putsln("    sub rax, rcx");
	}
	else if(expr.type == OP_MUL) {
		out.putsln("    imul rax, rcx");
	}
	else if(expr.type == OP_DIV) {
		out.putsln("    cqo");
		out.putsln("    idiv rcx");
	}
	else if(expr.type == OP_MOD) {
		out.putsln("    cqo");
		out.putsln("    idiv rcx");
		out.putsln("    mov rax, rdx");
	}
	else if(expr.type == OP_BWAND) {
		out.putsln("    and rax, rcx");
	}
	else if(expr.type == OP_BWOR) {
		out.putsln("    or rax, rcx");
	}
	else if(expr.type == OP_XOR) {
		out.putsln("    xor rax, rcx");
	}
	else if(expr.type == OP_LSH) {
		out.putsln("    sal rax, cl");
	}
	else if(expr.type == OP_RSH) {
		out.putsln("    sar rax, cl");
	}
	else if(expr.type == OP_EQUAL || expr.type == OP_NOT_EQUAL || expr.type == OP_LESS || expr.type == OP_LESS_EQ || expr.type == OP_GREATER || expr.type == OP_GREATER_EQ) {
		out.putsln("    cmp rax, rcx");
		out.puts("    set"); out.puts(cmp_suffix(expr.type)); out.putsln(" al");
		out.putsln("    movzx rax, al");
	}
	else {
		eputs("Unsupported type in generate_binary_rax - "); eputs(node_type_to_string(expr.type)); eputln();
		exit(1);
	}
}

function generate_call_rax(expr: Node*, out: File*) {
	if(expr.v.funktion.arguments.size > 6) {
		eputsln("Functions cannot have more than 6 arguments");
		eput_token_string(expr.v.funktion.name); eputln();
		exit(1);
	}

	for(var i = 0; i < expr.v.funktion.arguments.size; i = i + 1) {
		generate_expr_rax(expr.v.funktion.arguments.at(i), out);
		out.puts("    mov "); out.puts(cg_ARG_REGISTERS[i]); out.putsln(", rax");
	}

	out.puts("    call "); out.put_token_string(expr.v.funktion.name); out.putln();
}

function generate_ternary_rax(expr: Node*, out: File*) {
	generate_expr_rax(expr.v.conditional.condition, out);
	out.putsln("    test rax, rax");
	var falseLabel = cg_lableCount = cg_lableCount + 1;
	var endLabel = cg_lableCount = cg_lableCount + 1;

	out.puts("    je .l"); out.putd(falseLabel); out.putln();
	generate_expr_rax(expr.v.conditional.doTrue, out);
	out.puts("    jmp .l"); out.putd(endLabel); out.putln();

	out.puts(".l"); out.putd(falseLabel); out.putsln(":");
	generate_expr_rax(expr.v.conditional.doFalse, out);

	out.puts(".l"); out.putd(endLabel); out.putsln(":");
}

function generate_expr_rax(expr: Node*, out: File*) {
	if(is_unary_op(expr.type)) {
		generate_unary_rax(expr, out);
	}
	else if(is_binary_op(expr.type)) {
		generate_binary_rax(expr, out);
	}
	else if(expr.type == AST_INT_LITERAL) {
		out.puts("    mov rax, "); out.putd(expr.v.literal.az.integer); out.putln();
	}
	else if(expr.type == AST_ACCESS_VAR) {
		out.puts("    mov rax, QWORD [rbp-"); out.putd(expr.v.variable.stackOffset); out.putsln("]");
	}
	else if(expr.type == AST_ASSIGN_VAR) {
		generate_expr_rax(expr.v.variable.value, out);

		out.puts("    mov QWORD [rbp-"); out.putd(expr.v.variable.stackOffset); out.putsln("], rax");
	}
	else if(expr.type == AST_CALL) {
		generate_call_rax(expr, out);
	}
	else if(expr.type == OP_TERNARY) {
		generate_ternary_rax(expr, out);
	}
	else {
		eputs("Unsupported type in generate_expr_rax - "); eputs(node_type_to_string(expr.type)); eputln();
		exit(1);
	}
}

function generate_if_statement(ifStmt: Node*, out: File*) {
	generate_expr_rax(ifStmt.v.conditional.condition, out);
	out.putsln("    test rax, rax");
	var falseLabel = cg_lableCount = cg_lableCount + 1;
	var endLabel = cg_lableCount = cg_lableCount + 1;

	out.puts("    je .l"); out.putd(falseLabel); out.putln();

	generate_statement(ifStmt.v.conditional.doTrue, out);

	if(ifStmt.v.conditional.doFalse != null) {
		out.puts("    jmp .l"); out.putd(endLabel); out.putln();
	}

	out.puts(".l"); out.putd(falseLabel); out.putsln(":");

	if(ifStmt.v.conditional.doFalse != null) {
		generate_statement(ifStmt.v.conditional.doFalse, out);
		out.puts(".l"); out.putd(endLabel); out.putsln(":");
	}
}

function generate_while_statement(whileStmt: Node*, out: File*) {
	var condLabel = cg_lableCount = cg_lableCount + 1;
	var bodyLabel = cg_lableCount = cg_lableCount + 1;

	out.puts("    jmp .l"); out.putd(condLabel); out.putln();
	out.puts(".l"); out.putd(bodyLabel); out.putsln(":");

	generate_statement(whileStmt.v.conditional.doTrue, out);

	out.puts(".l"); out.putd(condLabel); out.putsln(":");
	generate_expr_rax(whileStmt.v.conditional.condition, out);
	out.putsln("    test rax, rax");
	out.puts("    jne .l"); out.putd(bodyLabel); out.putln();
}

function generate_statement(stmt: Node*, out: File*) {
	if(stmt.type == AST_IF) {
		generate_if_statement(stmt, out);
	}
	else if(stmt.type == AST_WHILE) {
		generate_while_statement(stmt, out);
	}
	else if(stmt.type == AST_RETURN) {
		generate_expr_rax(stmt.v.unary, out);
		out.putsln("    leave");
		out.putsln("    ret");
	}
	else if(stmt.type == AST_DEFINE_VAR) {
		if(stmt.v.variable.value != null) {
			generate_expr_rax(stmt.v.variable.value, out);

			out.puts("    mov QWORD [rbp-"); out.putd(stmt.v.variable.stackOffset); out.putsln("], rax");
		}
	}
	else if(stmt.type == AST_EXPR_STMT) {
		generate_expr_rax(stmt.v.unary, out);
	}
	else if(stmt.type == AST_BLOCK) {
		generate_block(stmt, out);
	}
	else {
		eputs("Unsupported type in generate_statement - "); eputs(node_type_to_string(stmt.type)); eputln();
		exit(1);
	}
}

function generate_block(block: Node*, out: File*) {
	for(var i = 0; i < block.v.block.children.size; i = i + 1) {
		generate_statement(block.v.block.children.at(i), out);
	}
}

function generate_function(funktion: Node*, out: File*) {
	out.puts("global "); out.put_token_string(funktion.v.funktion.name); out.putln();
	out.put_token_string(funktion.v.funktion.name); out.putsln(":");

	out.putsln("    push rbp");
	out.putsln("    mov rbp, rsp");

	var stackDepth = ceil_multiple(funktion.v.funktion.localVariableStackOffset, 16);
	if(stackDepth != 0) {
		out.puts("    sub rsp, "); out.putd(stackDepth); out.putln();
	}
	
	if(funktion.v.funktion.arguments.size > 6) {
		eputsln("Functions cannot have more than 6 arguments");
		eput_token_string(funktion.v.funktion.name);
		exit(1);
	}

	for(var i = 0; i < funktion.v.funktion.arguments.size; i = i + 1) {
		out.puts("mov QWORD [rbp-"); out.putd((funktion.v.funktion.arguments.at(i) as Node*).v.variable.stackOffset); out.puts("], "); out.putsln(cg_ARG_REGISTERS[i]);
	}

	generate_block(funktion.v.funktion.body, out);
}

function generate_implicit_printu_impl(out: File*) {
	out.putsln("printu:");
	out.putsln("		sub     rsp, 40");
	out.putsln("		mov     eax, 10");
	out.putsln("		mov     esi, 19");
	out.putsln("		mov  r10, -3689348814741910323");
	out.putsln("		mov     WORD [rsp+20], ax");
	out.putsln("		lea     r8, [rsp+19]");
	out.putsln(".L2:");
	out.putsln("		mov     rax, rdi");
	out.putsln("		movsxd  r9, esi");
	out.putsln("		sub     r8, 1");
	out.putsln("		sub     esi, 1");
	out.putsln("		mul     r10");
	out.putsln("		mov     rax, rdi");
	out.putsln("		shr     rdx, 3");
	out.putsln("		lea     rcx, [rdx+rdx*4]");
	out.putsln("		add     rcx, rcx");
	out.putsln("		sub     rax, rcx");
	out.putsln("		mov     rcx, rdi");
	out.putsln("		mov     rdi, rdx");
	out.putsln("		add     eax, 48");
	out.putsln("		mov     BYTE [r8+1], al");
	out.putsln("		cmp     rcx, 9");
	out.putsln("		ja      .L2");
	out.putsln("		mov     rdi, 1");
	out.putsln("		mov     edx, 20");
	out.putsln("		mov     rax, 1");
	out.putsln("		sub     edx, esi");
	out.putsln("		lea     rsi, [rsp+r9]");
	out.putsln("		syscall");
	out.putsln("		add     rsp, 40");
	out.putsln("		ret");
}

function generate_program(ast: Node*, out: File*) {
	generate_implicit_printu_impl(out);

	for(var i = 0; i < ast.v.block.children.size; i = i + 1) {
		var node: Node* = ast.v.block.children.at(i);
		if(node.type == AST_FUNCTION) {
			generate_function(node, out);
		}
		else {
			eputs("Unsupported type in generate_program - "); eputs(node_type_to_string(node.type)); eputln();
			exit(1);
		}
	}

	// Entry point of _start -> calls main and exits (via syscall)
	// Uses main's return value as the exit code
	out.putsln("global _start");
	out.putsln("_start:");
	out.putsln("    call main");
	out.putsln("    mov rdi, rax");
	out.putsln("    mov rax, 60");
	out.putsln("    syscall");
}