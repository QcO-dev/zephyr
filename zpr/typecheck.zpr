import "std/core.zpr";
import "std/vector.zpr";

var tc_typeStack = new_vector();

function Type.is_integral(): int {
	return this.indirection == 0 && (
		this.type == DATA_TYPE_INT ||
		this.type == DATA_TYPE_I8 ||
		this.type == DATA_TYPE_I16 ||
		this.type == DATA_TYPE_I32 ||
		this.type == DATA_TYPE_I64
	);
}

function Type.assignable(b: Type*): int {
	if(this.is_integral() && b.is_integral()) {
		return true;
	}

	return this.type == b.type && this.indirection == b.indirection;
}

function Type.size(): int {
	if(this.indirection != 0) return 8;

	if(this.type == DATA_TYPE_INT) return 8;
	if(this.type == DATA_TYPE_I8) return 1;
	if(this.type == DATA_TYPE_I16) return 2;
	if(this.type == DATA_TYPE_I32) return 4;
	if(this.type == DATA_TYPE_I64) return 8;

	eputsln("Unreachable - VOID_TYPE.size");
	exit(1);
	return 0;
}

function Node.print_position() {
	eputs("["); eputd(this.position.line); eputs("] Error ");

	if(this.position.type == TOKEN_EOF) {
		eputs("@ EOF");
	}
	else {
		eputs("@ '"); eput_token_string(this.position); eputs("'");
	}
	eputs(": ");
}

function Parser.lookup_variable(name: Token*): Node* {
	var block = this.currentBlock;

	while(block != null) {
		var variable = this.lookup_scope_variable(name, block);
		if(variable != null) return variable;
		block = block.v.block.parent;
	}

	for(var i = 0; i < this.currentFunction.v.funktion.arguments.size; i = i + 1) {
		var arg: Node* = this.currentFunction.v.funktion.arguments.at(i);

		if(arg.v.variable.name.equals(name)) {
			return arg;
		}
	}

	for(var i = 0; i < this.globalVars.size; i = i + 1) {
		var variable: Node* = this.globalVars.at(i);

		if(variable.v.variable.name.equals(name)) {
			return variable;
		}
	}

	for(var i = 0; i < this.functions.size; i = i + 1) {
		var func: Node* = this.functions.at(i);
		if(func.v.funktion.name.equals(name)) {
			return func;
		}
	}

	return null;
}

function Parser.lookup_scope_variable(name: Token*, block: Node*): Node* {
	for(var i = 0; i < block.v.block.variables.size; i = i + 1) {
		var variable: Node* = block.v.block.variables.at(i);

		if(variable.v.variable.name.equals(name)) {
			return variable;
		}
	}
	return null;
}

function Parser.lookup_same_scope_variable(name: Token*): Node* {
	return this.lookup_scope_variable(name, this.currentBlock);
}

function Parser.lookup_global_variable(name: Token*): Node* {
	for(var i = 0; i < this.globalVars.size; i = i + 1) {
		var variable: Node* = this.globalVars.at(i);

		if(variable.v.variable.name.equals(name)) {
			return variable;
		}
	}
	return null;
}

function Parser.type_check_addrof(expr: Node*) {
	if(!expr.v.unary.lvalue) {
		expr.print_position();
		eputsln("Expected lvalue as operand for unary '&'");
		exit(1);
	}

	this.type_check_expr(expr.v.unary);
	var type: Type* = tc_typeStack.pop();

	var addrType = copy_type(type);
	addrType.indirection = addrType.indirection + 1;

	tc_typeStack.push(addrType);
}

function Parser.type_check_deref(expr: Node*) {
	this.type_check_expr(expr.v.unary);
	var type: Type* = tc_typeStack.pop();

	if(type.indirection == 0) {
		expr.print_position();
		eputs("Cannot dereference non-pointer type '"); eputs(type_to_string(type)); eputsln("'");
		exit(1);
	}

	var derefType = copy_type(type);
	derefType.indirection = derefType.indirection - 1;

	expr.computedType = derefType;
	tc_typeStack.push(derefType);
}

function Parser.type_check_unary(expr: Node*) {
	if(expr.type == OP_ADDROF) {
		this.type_check_addrof(expr);
		return;
	}
	else if(expr.type == OP_DEREF) {
		this.type_check_deref(expr);
		return;
	}

	this.type_check_expr(expr.v.unary);

	var type: Type* = tc_typeStack.top();

	if(!type.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot perform operation '"); eputs(node_type_to_string(expr.type)); eputs("' on type '"); eputs(type_to_string(type)); eputsln("'");
		exit(1);
	}
}

function Parser.type_check_binary(expr: Node*) {
	this.type_check_expr(expr.v.binary.lhs);
	var left: Type* = tc_typeStack.pop();

	this.type_check_expr(expr.v.binary.rhs);
	var right: Type* = tc_typeStack.pop();

	if(!left.assignable(INT_TYPE) || !right.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot perform operation '"); eputs(node_type_to_string(expr.type)); eputs("' on types '"); eputs(type_to_string(left));
		eputs("' and '"); eputs(type_to_string(right)); eputsln("'");
		exit(1);
	}

	tc_typeStack.push(left);
}

function Parser.type_check_access_var(expr: Node*) {
	var variable = this.lookup_variable(expr.v.variable.name);

	if(variable == null) {
		expr.print_position();
		eputs("Unknown variable '"); eput_token_string(expr.v.variable.name); eputsln("' in current scope");
		exit(1);
	}

	if(variable.type == AST_DEFINE_VAR) {
		expr.v.variable.type = variable.v.variable.type;
		expr.v.variable.stackOffset = variable.v.variable.stackOffset;

		tc_typeStack.push(expr.v.variable.type);
	}
	else if(variable.type == AST_DEFINE_GLOBAL_VAR) {
		expr.v.variable.type = variable.v.variable.type;
		expr.type = AST_ACCESS_GLOBAL_VAR;

		tc_typeStack.push(expr.v.variable.type);
	}
	else {
		expr.print_position();
		eputsln("Can only access variables");
		exit(1);
	}
}

function Parser.type_check_assign_var(expr: Node*) {
	var variable = this.lookup_variable(expr.v.variable.name);

	if(variable == null) {
		expr.print_position();
		eputs("Unknown variable '"); eput_token_string(expr.v.variable.name); eputsln("' in current scope");
		exit(1);
	}

	this.type_check_expr(expr.v.variable.value);

	var valueType: Type* = tc_typeStack.pop();

	if(variable.type == AST_DEFINE_VAR) {
		if(!valueType.assignable(variable.v.variable.type)) {
			expr.print_position();
			eputs("Cannot assign type '"); eputs(type_to_string(valueType)); eputs("' to variable of type '"); eputs(type_to_string(variable.v.variable.type));
			eputsln("'");
			exit(1);
		}

		expr.v.variable.type = variable.v.variable.type;
		expr.v.variable.stackOffset = variable.v.variable.stackOffset;

		tc_typeStack.push(expr.v.variable.type);
	}
	else if(variable.type == AST_DEFINE_GLOBAL_VAR) {
		if(!valueType.assignable(variable.v.variable.type)) {
			expr.print_position();
			eputs("Cannot assign type '"); eputs(type_to_string(valueType)); eputs("' to variable of type '"); eputs(type_to_string(variable.v.variable.type));
			eputsln("'");
			exit(1);
		}

		expr.v.variable.type = variable.v.variable.type;
		expr.type = AST_ASSIGN_GLOBAL_VAR;

		tc_typeStack.push(expr.v.variable.type);
	}
	else {
		expr.print_position();
		eputsln("Can only assign variables");
		exit(1);
	}
	
}

function Parser.type_check_call(expr: Node*) {
	var funktion = this.lookup_variable(expr.v.funktion.name);

	if(funktion == null) {
		expr.print_position();
		eputs("Unknown variable '"); eput_token_string(expr.v.variable.name); eputsln("' in current scope");
		exit(1);
	}

	if(funktion.type != AST_FUNCTION) {
		expr.print_position();
		eputsln("Can only call functions");
		exit(1);
	}

	if(funktion.v.funktion.arguments.size != expr.v.funktion.arguments.size) {
		expr.print_position();
		eputs("Call expected "); eputd(funktion.v.funktion.arguments.size); eputs(" arguments but got "); eputd(expr.v.funktion.arguments.size); eputln();
		exit(1);
	}

	for(var i = 0; i < funktion.v.funktion.arguments.size; i = i + 1) {
		var arg: Node* = expr.v.funktion.arguments.at(i);
		this.type_check_expr(arg);

		var argType: Type* = tc_typeStack.pop();
		
		var param: Node* = funktion.v.funktion.arguments.at(i);
		var paramType = param.v.variable.type;

		if(!argType.assignable(paramType)) {
			expr.print_position();
			eputs("Function argument "); eputd(i + 1); eputs(" expected type '"); eputs(type_to_string(paramType)); eputs("' but got '");
			eputs(type_to_string(argType)); eputsln("'");
		}
	}

	tc_typeStack.push(funktion.v.funktion.returnType);
}

function Parser.type_check_ternary_expr(expr: Node*) {
	this.type_check_expr(expr.v.conditional.condition);
	var condition: Type* = tc_typeStack.pop();

	if(!condition.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot use type '"); eputs(type_to_string(condition)); eputsln("as a condition");
		exit(1);
	}

	this.type_check_expr(expr.v.conditional.doTrue);
	var doTrue: Type* = tc_typeStack.pop();

	this.type_check_expr(expr.v.conditional.doFalse);
	var doFalse: Type* = tc_typeStack.pop();

	if(!doTrue.assignable(doFalse)) {
		expr.print_position();
		eputs("Cannot conditionally return differing types '"); eputs(type_to_string(doTrue)); eputs("' and '"); eputs(type_to_string(doFalse)); eputsln("'");
		exit(1);
	}

	tc_typeStack.push(doTrue);
}

function Parser.type_check_expr(expr: Node*) {
	if(is_unary_op(expr.type)) {
		this.type_check_unary(expr);
	}
	else if(is_binary_op(expr.type)) {
		this.type_check_binary(expr);
	}
	else if(expr.type == AST_INT_LITERAL) {
		tc_typeStack.push(INT_TYPE);
	}
	else if(expr.type == AST_ACCESS_VAR) {
		this.type_check_access_var(expr);
	}
	else if(expr.type == AST_ASSIGN_VAR) {
		this.type_check_assign_var(expr);
	}
	else if(expr.type == AST_CALL) {
		this.type_check_call(expr);
	}
	else if(expr.type == OP_TERNARY) {
		this.type_check_ternary_expr(expr);
	}
	else if(expr.type == OP_SIZEOF) {
		tc_typeStack.push(INT_TYPE);
	}
	else {
		eputsln("Unreachable - type_check_expr");
		exit(1);
	}
}

function Parser.type_check_define_var(stmt: Node*) {
	var declType = stmt.v.variable.type;

	var name = stmt.v.variable.name;

	var redeclaration = this.lookup_same_scope_variable(name);

	if(redeclaration != null) {
		stmt.print_position();
		eputs("Redeclaration of variable '"); eput_token_string(name); eputsln("' in current scope");
		exit(1);
	}

	if(declType.type == DATA_TYPE_VOID && stmt.v.variable.value == null) {
		stmt.print_position();
		eputsln("Cannot infer type to variable without initial value");
		exit(1);
	}

	if(declType.type == DATA_TYPE_VOID) {
		this.type_check_expr(stmt.v.variable.value);
		stmt.v.variable.type = tc_typeStack.pop();
		declType = stmt.v.variable.type;
	}

	stmt.v.variable.stackOffset = this.currentBlock.v.block.currentStackOffset = this.currentBlock.v.block.currentStackOffset + declType.size();

	if(stmt.v.variable.stackOffset > this.currentFunction.v.funktion.localVariableStackOffset) {
		this.currentFunction.v.funktion.localVariableStackOffset = stmt.v.variable.stackOffset;
	}

	if(stmt.v.variable.value != null) {
		this.type_check_expr(stmt.v.variable.value);

		var valueType: Type* = tc_typeStack.pop();

		if(!valueType.assignable(declType)) {
			stmt.print_position();
			eputs("Cannot assign type '"); eputs(type_to_string(valueType)); eputs("' to variable expecting '"); eputs(type_to_string(declType));
			eputsln("'");
			exit(1);
		}
	}

	this.currentBlock.v.block.variables.push(stmt);
}

function Parser.type_check_if_statement(stmt: Node*) {
	this.type_check_expr(stmt.v.conditional.condition);

	var conditionType: Type* = tc_typeStack.pop();

	if(!conditionType.assignable(INT_TYPE)) {
		stmt.print_position();
		eputs("Expected condition to be type 'int' but got '"); eputs(type_to_string(conditionType)); eputsln("'");
		exit(1);
	}

	this.type_check_statement(stmt.v.conditional.doTrue);

	if(stmt.v.conditional.doFalse != null)
		this.type_check_statement(stmt.v.conditional.doFalse);
}

function Parser.type_check_while_statement(stmt: Node*) {
	this.type_check_expr(stmt.v.conditional.condition);

	var conditionType: Type* = tc_typeStack.pop();

	if(!conditionType.assignable(INT_TYPE)) {
		stmt.print_position();
		eputs("Expected condition to be type 'int' but got '"); eputs(type_to_string(conditionType)); eputsln("'");
		exit(1);
	}

	this.type_check_statement(stmt.v.conditional.doTrue);
}

function Parser.type_check_for_statement(stmt: Node*) {
	if(stmt.v.loop.initial != null) this.type_check_statement(stmt.v.loop.initial);
	if(stmt.v.loop.condition != null) {
		this.type_check_expr(stmt.v.loop.condition);
		var conditionType: Type* = tc_typeStack.pop();

		if(!conditionType.assignable(INT_TYPE)) {
			stmt.print_position();
			eputs("Expected condition to be type 'int' but got '"); eputs(type_to_string(conditionType)); eputsln("'");
			exit(1);
		}
	}
	if(stmt.v.loop.iteration != null) {
		this.type_check_expr(stmt.v.loop.iteration);
		tc_typeStack.pop();
	}

	this.type_check_statement(stmt.v.loop.body);
}

function Parser.type_check_statement(stmt: Node*) {
	if(stmt.type == AST_IF) {
		this.type_check_if_statement(stmt);
	}
	else if(stmt.type == AST_WHILE) {
		this.type_check_while_statement(stmt);
	}
	else if(stmt.type == AST_FOR) {
		this.type_check_for_statement(stmt);
	}
	else if(stmt.type == AST_RETURN) {
		this.type_check_expr(stmt.v.unary);

		var returnType: Type* = tc_typeStack.pop();
		var expectedType = this.currentFunction.v.funktion.returnType;
		if(!returnType.assignable(expectedType)) {
			stmt.print_position();
			eputs("Cannot return type '"); eputs(type_to_string(returnType)); eputs("' from function expecting '"); eputs(type_to_string(expectedType));
			eputsln("'");
			exit(1);
		}
	}
	else if(stmt.type == AST_DEFINE_VAR) {
		this.type_check_define_var(stmt);
	}
	else if(stmt.type == AST_EXPR_STMT) {
		this.type_check_expr(stmt.v.unary);
	}
	else if(stmt.type == AST_BLOCK) {
		this.type_check_block(stmt);
	}
	else {
		eputsln("Unreachable - type_check_statement");
		exit(1);
	}
}

function Parser.type_check_block(block: Node*) {
	block.v.block.variables = new_vector();
	block.v.block.currentStackOffset = this.currentBlock.v.block.currentStackOffset;
	this.currentBlock = block;

	for(var i = 0; i < block.v.block.children.size; i = i + 1) {
		this.type_check_statement(block.v.block.children.at(i));
	}

	this.currentBlock = block.v.block.parent;
}

function Parser.type_check_function(funktion: Node*) {
	var stackOffset = 0;

	for(var i = 0; i < funktion.v.funktion.arguments.size; i = i + 1) {
		var arg: Node* = funktion.v.funktion.arguments.at(i);

		stackOffset = stackOffset + arg.v.variable.type.size();

		arg.v.variable.stackOffset = stackOffset;
	}

	funktion.v.funktion.body.v.block.currentStackOffset = stackOffset;
	funktion.v.funktion.localVariableStackOffset = stackOffset;

	this.currentFunction = funktion;

	this.currentBlock = funktion.v.funktion.body;
	this.type_check_block(funktion.v.funktion.body);
}

function Parser.type_check_global_var(stmt: Node*) {
	var declType = stmt.v.variable.type;
	var name = stmt.v.variable.name;

	var redeclaration = this.lookup_global_variable(name);

	if(redeclaration != null) {
		stmt.print_position();
		eputs("Redeclaration of variable '"); eput_token_string(name); eputsln("' in current scope");
		exit(1);
	}

	if(declType.type == DATA_TYPE_VOID && stmt.v.variable.value == null) {
		stmt.print_position();
		eputsln("Cannot infer type to variable without initial value");
		exit(1);
	}

	if(declType.type == DATA_TYPE_VOID) {
		this.type_check_expr(stmt.v.variable.value);
		stmt.v.variable.type = tc_typeStack.pop();
		declType = stmt.v.variable.type;
	}

	if(stmt.v.variable.value != null) {
		this.type_check_expr(stmt.v.variable.value);

		var valueType: Type* = tc_typeStack.pop();

		if(!valueType.assignable(declType)) {
			stmt.print_position();
			eputs("Cannot assign type '"); eputs(type_to_string(valueType)); eputs("' to variable expecting '"); eputs(type_to_string(declType));
			eputsln("'");
			exit(1);
		}
	}

	this.globalVars.push(stmt);
}

function Parser.type_check(program: Node*) {
	for(var i = 0; i < program.v.block.children.size; i = i + 1) {
		var node: Node* = program.v.block.children.at(i);

		if(node.type == AST_FUNCTION) {
			if(!node.v.funktion.hasImplicitBody)
				this.type_check_function(node);
		}
		else if(node.type == AST_DEFINE_GLOBAL_VAR) {
			this.type_check_global_var(node);
		}
		else {
			eputsln("Unreachable - unhandled node type in type_check (program)");
			exit(1);
		}
	}
}