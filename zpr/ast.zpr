import "std/vector.zpr";

// Updating this list requires updating node_type_to_string and print_ast_depth
var __nt_count = -1;
var OP_BWNOT = __nt_count = __nt_count + 1;
var OP_NEG = __nt_count = __nt_count + 1;
var OP_NOT = __nt_count = __nt_count + 1;
var OP_ADD = __nt_count = __nt_count + 1;
var OP_SUB = __nt_count = __nt_count + 1;
var OP_MUL = __nt_count = __nt_count + 1;
var OP_DIV = __nt_count = __nt_count + 1;
var OP_MOD = __nt_count = __nt_count + 1;
var OP_BWAND = __nt_count = __nt_count + 1;
var OP_BWOR = __nt_count = __nt_count + 1;
var OP_XOR = __nt_count = __nt_count + 1;
var OP_LSH = __nt_count = __nt_count + 1;
var OP_RSH = __nt_count = __nt_count + 1;
var OP_EQUAL = __nt_count = __nt_count + 1;
var OP_NOT_EQUAL = __nt_count = __nt_count + 1;
var OP_LESS = __nt_count = __nt_count + 1;
var OP_LESS_EQ = __nt_count = __nt_count + 1;
var OP_GREATER = __nt_count = __nt_count + 1;
var OP_GREATER_EQ = __nt_count = __nt_count + 1;
var OP_TERNARY = __nt_count = __nt_count + 1;
var AST_INT_LITERAL = __nt_count = __nt_count + 1;
var AST_CALL = __nt_count = __nt_count + 1;
var AST_DEFINE_VAR = __nt_count = __nt_count + 1;
var AST_ACCESS_VAR = __nt_count = __nt_count + 1;
var AST_ASSIGN_VAR = __nt_count = __nt_count + 1;
var AST_EXPR_STMT = __nt_count = __nt_count + 1;
var AST_IF = __nt_count = __nt_count + 1;
var AST_WHILE = __nt_count = __nt_count + 1;
var AST_RETURN = __nt_count = __nt_count + 1;
var AST_FUNCTION = __nt_count = __nt_count + 1;
var AST_BLOCK = __nt_count = __nt_count + 1;
var AST_PROGRAM = __nt_count = __nt_count + 1;

// Updating this list requires updating data_type_to_string
var __dt_count = 0;
var DATA_TYPE_VOID = 0;
var DATA_TYPE_INT = __dt_count = __dt_count + 1;

struct Type {
	type: int; // DataType
}

struct Node {
	type: int; // NodeType
	position: Token*;

	v: union {
		unary: Node*;

		binary: struct {
			lhs: Node*;
			rhs: Node*;
		};

		conditional: struct {
			condition: Node*;
			doTrue: Node*;
			doFalse: Node*;
		};

		funktion: struct {
			name: Token*;
			returnType: Type;
			body: Node*;
			hasImplicitBody: int;

			arguments: Vector*;

			localVariableStackOffset: int;
		};

		block: struct {
			children: Vector*;

			parent: Node*;
			variables: Vector*;
			currentStackOffset: int;
		};

		literal: struct {
			type: Type;

			az: union {
				integer: int;
			};
		};

		variable: struct {
			name: Token*;
			type: Type;
			value: Node*;

			stackOffset: int;
		};
	};
}

function data_type_to_string(type: int): i8* {
	if(type == DATA_TYPE_VOID) return "void";
	if(type == DATA_TYPE_INT) return "int";

	return "<unknown type>";
}

function type_to_string(type: Type*): i8* {
	return data_type_to_string(type.type);
}

function node_type_to_string(type: int): i8* {
	if(type == OP_BWNOT) return "~";
	if(type == OP_NEG) return "-";
	if(type == OP_NOT) return "!";
	if(type == OP_ADD) return "+";
	if(type == OP_SUB) return "-";
	if(type == OP_MUL) return "*";
	if(type == OP_DIV) return "/";
	if(type == OP_MOD) return "%";
	if(type == OP_BWAND) return "&";
	if(type == OP_BWOR) return "|";
	if(type == OP_XOR) return "^";
	if(type == OP_LSH) return "<<";
	if(type == OP_RSH) return ">>";
	if(type == OP_EQUAL) return "==";
	if(type == OP_NOT_EQUAL) return "!=";
	if(type == OP_LESS) return "<";
	if(type == OP_LESS_EQ) return "<=";
	if(type == OP_GREATER) return ">";
	if(type == OP_GREATER_EQ) return ">=";
	if(type == OP_TERNARY) return "?";
	if(type == AST_INT_LITERAL) return "int literal";
	if(type == AST_CALL) return "call";
	if(type == AST_DEFINE_VAR) return "define var";
	if(type == AST_ACCESS_VAR) return "access var";
	if(type == AST_ASSIGN_VAR) return "assign var";
	if(type == AST_EXPR_STMT) return "expr stmt";
	if(type == AST_IF) return "if";
	if(type == AST_WHILE) return "while";
	if(type == AST_RETURN) return "return";
	if(type == AST_FUNCTION) return "function";
	if(type == AST_BLOCK) return "block";
	if(type == AST_PROGRAM) return "program";

	return "<unknown node type>";
}

function is_unary_op(type: int): int {
	return (
		type == OP_BWNOT ||
		type == OP_NEG ||
		type == OP_NOT
	);
}

function is_binary_op(type: int): int {
	return (
		type == OP_ADD ||
		type == OP_SUB ||
		type == OP_MUL ||
		type == OP_DIV ||
		type == OP_MOD ||
		type == OP_BWAND ||
		type == OP_BWOR ||
		type == OP_XOR ||
		type == OP_LSH ||
		type == OP_RSH ||
		type == OP_EQUAL ||
		type == OP_NOT_EQUAL ||
		type == OP_LESS ||
		type == OP_LESS_EQ ||
		type == OP_GREATER ||
		type == OP_GREATER_EQ
	);
}

function print_ast_depth(node: Node*, depth: int) {
	for(var i = 0; i < depth; i = i + 1) puts("  ");

	if(is_unary_op(node.type)) {
		putsln(node_type_to_string(node.type));
		print_ast_depth(node.v.unary, depth + 1);
	}
	else if(is_binary_op(node.type)) {
		putsln(node_type_to_string(node.type));
		print_ast_depth(node.v.binary.lhs, depth + 1);
		putln();
		print_ast_depth(node.v.binary.rhs, depth + 1);
	}
	else if(node.type == AST_PROGRAM) {
		for(var i = 0; i < node.v.block.children.size; i = i + 1)
			print_ast_depth(node.v.block.children.at(i), depth);
	}
	else if(node.type == AST_BLOCK) {
		putsln("{");
		for(var i = 0; i < node.v.block.children.size; i = i + 1)
			print_ast_depth(node.v.block.children.at(i), depth + 1);
		for(var i = 0; i < depth; i = i + 1) puts("  ");
		putsln("}");
	}
	else if(node.type == AST_FUNCTION) {
		puts("function "); put_token_string(node.v.funktion.name); puts(": "); putsln(type_to_string(&node.v.funktion.returnType));
		for(var i = 0; i < node.v.funktion.arguments.size; i = i + 1) {
			var arg: Node* = node.v.funktion.arguments.at(i);
			puts("("); put_token_string(arg.v.variable.name); puts(": "); puts(type_to_string(&arg.v.variable.type)); puts(") ");
		}
		if(node.v.funktion.arguments.size > 0) putln();
		if(!node.v.funktion.hasImplicitBody)
			print_ast_depth(node.v.funktion.body, depth);
	}
	else if(node.type == AST_CALL) {
		puts("call "); put_token_string(node.v.funktion.name); putln();
		for(var i = 0; i < node.v.funktion.arguments.size; i = i + 1) {
			var arg: Node* = node.v.funktion.arguments.at(i);
			print_ast_depth(arg, depth + 1);
			if(i != node.v.funktion.arguments.size -1 ) putln();
		}
	}
	else if(node.type == AST_EXPR_STMT) {
		putsln("pop");
		print_ast_depth(node.v.unary, depth + 1);
		putln();
	}
	else if(node.type == AST_IF) {
		putsln("if");
		print_ast_depth(node.v.conditional.condition, depth + 1);
		putln();
		print_ast_depth(node.v.conditional.doTrue, depth + 1);
		putln();

		if(node.v.conditional.doFalse != null) {
			for(var i = 0; i < depth; i = i + 1) puts("  ");
			putsln("else");
			print_ast_depth(node.v.conditional.doFalse, depth + 1);
			putln();
		}
	}
	else if(node.type == AST_WHILE) {
		putsln("while");
		print_ast_depth(node.v.conditional.condition, depth + 1);
		putln();
		print_ast_depth(node.v.conditional.doTrue, depth + 1);
		putln();
	}
	else if(node.type == AST_RETURN) {
		putsln("return");
		print_ast_depth(node.v.unary, depth + 1);
		putln();
	}
	else if(node.type == AST_DEFINE_VAR) {
		puts("var "); put_token_string(node.v.variable.name); puts(": "); putsln(type_to_string(&node.v.variable.type));
		if(node.v.variable.value != null) {
			print_ast_depth(node.v.variable.value, depth + 1);
			putln();
		}
	}
	else if(node.type == AST_ACCESS_VAR) {
		puts("(var "); put_token_string(node.v.variable.name); puts(")");
	}
	else if(node.type == AST_ASSIGN_VAR) {
		put_token_string(node.v.variable.name); putsln(" =");
		print_ast_depth(node.v.variable.value, depth + 1);
	}
	else if(node.type == AST_INT_LITERAL) {
		puts("(literal "); putd(node.v.literal.az.integer); puts(")");
	}
	else if(node.type == OP_TERNARY) {
		putsln("?");
		print_ast_depth(node.v.conditional.condition, depth + 1);
		putln();
		print_ast_depth(node.v.conditional.doTrue, depth + 1);
		putsln(":");
		print_ast_depth(node.v.conditional.doFalse, depth + 1);
	}
	else {
		eputs("Cannot handle type in print_ast_depth - "); eputsln(node_type_to_string(node.type));
	}
}

function print_ast(ast: Node*) {
	print_ast_depth(ast, 0);
}
