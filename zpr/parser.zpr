import "std/core.zpr";
import "zpr/types.zpr";
import "zpr/lexer.zpr";
import "zpr/ast.zpr";

struct Parser {
	lexer: Lexer*;
	current: Token*;
	previous: Token*;

	currentFunction: Node*;
	currentBlock: Node*;

	functions: Vector*;

	globalVars: Vector*;

	error: int;
	panic: int;
}

function new_parser(lexer: Lexer*): Parser* {
	var parser: Parser* = malloc(sizeof(Parser));
	parser.lexer = lexer;
	parser.functions = new_vector();
	parser.globalVars = new_vector();
	return parser;
}

function new_node(type: int, position: Token*): Node* {
	var node: Node* = malloc(sizeof(Node));
	node.type = type;
	node.position = position;
	return node;
}

function Node.add_child(child: Node*) {
	this.v.block.children.push(child);
}

function Parser.error_at_token(token: Token*, message: i8*) {
	if(this.panic) return;
	this.panic = true;
	eputs("["); eputd(token.line); eputs("] Error");

	if(token.type == TOKEN_EOF) {
		eputs(" @ EOF");
	}
	else if(token.type == TOKEN_ERROR) {
		// No value to print
	}
	else {
		eputs(" @ '"); eput_token_string(token); eputs("'");
	}

	eputs(": "); eputsln(message);

	this.error = true;
}

function Parser.error(message: i8*) {
	this.error_at_token(this.previous, message);
}

function Parser.error_current(message: i8*) {
	this.error_at_token(this.current, message);
}

function Parser.advance() {
	this.previous = this.current;

	for(;;) {
		this.current = this.lexer.next();
		if(this.current.type != TOKEN_ERROR) break;

		this.error_current(this.current.start);
	}
}

function Parser.consume(type: int, message: i8*): Token* {
	if(this.current.type == type) {
		this.advance();
		return this.previous;
	}

	this.error_current(message);
	return this.current;
}

function Parser.check(type: int): int {
	return this.current.type == type;
}

function Parser.match(type: int): int {
	if(!this.check(type)) return false;
	this.advance();
	return true;
}

function Parser.parse_type(): Type* {
	this.advance();

	var type = new_type();

	if(this.previous.type == TOKEN_INT) type.type = DATA_TYPE_INT;
	else if(this.previous.type == TOKEN_I8) type.type = DATA_TYPE_I8;
	else if(this.previous.type == TOKEN_I16) type.type = DATA_TYPE_I16;
	else if(this.previous.type == TOKEN_I32) type.type = DATA_TYPE_I32;
	else if(this.previous.type == TOKEN_I64) type.type = DATA_TYPE_I64;
	else {
		this.error("Expected type");
	}

	while(this.match(TOKEN_STAR)) {
		type.indirection = type.indirection + 1;
	}

	return type;
}

function Parser.parse_identifier(): Node* {
	var name = this.previous;

	if(this.match(TOKEN_EQ)) {
		var value = this.parse_expression();

		var assign = new_node(AST_ASSIGN_VAR, name);
		assign.v.variable.name = name;
		assign.v.variable.value = value;
		return assign;
	}
	else if(this.match(TOKEN_LEFT_PAREN)) {
		var call = new_node(AST_CALL, name);
		call.v.funktion.name = name;
		call.v.funktion.arguments = new_vector();

		if(!this.check(TOKEN_RIGHT_PAREN)) {
			var arg = this.parse_expression();

			call.v.funktion.arguments.push(arg);

			while(this.match(TOKEN_COMMA)) {
				var arg = this.parse_expression();

				call.v.funktion.arguments.push(arg);
			}
		}

		this.consume(TOKEN_RIGHT_PAREN, "Expected ')' after function arguments");

		return call;
	}

	var access = new_node(AST_ACCESS_VAR, name);
	access.v.variable.name = name;
	access.lvalue = LVALUE_IDENTIFIER;
	return access;
}

function Parser.parse_value(): Node* {
	if(this.match(TOKEN_INT_LITERAL)) {
		var literal = this.previous;
		if(this.error) return null;

		var literalNode = new_node(AST_INT_LITERAL, literal);
		literalNode.v.literal.type = INT_TYPE;
		literalNode.v.literal.az.integer = atoi(literal.start);

		return literalNode;
	}
	else if(this.match(TOKEN_IDENTIFIER)) {
		return this.parse_identifier();
	}
	else if(this.match(TOKEN_SIZEOF)) {
		var expr = new_node(OP_SIZEOF, this.previous);
		this.consume(TOKEN_LEFT_PAREN, "Expected '(' after sizeof");
		var type = this.parse_type();
		this.consume(TOKEN_RIGHT_PAREN, "Expected ')' after sizeof type");
		expr.computedType = type;
		return expr;
	}
	else if(this.match(TOKEN_LEFT_PAREN)) {
		var expr = this.parse_expression();
		this.consume(TOKEN_RIGHT_PAREN, "Expected closing ')' after expression");
		return expr;
	}

	this.error_current("Expected value");
	return null;
}

function Parser.parse_unary(): Node* {
	if(this.match(TOKEN_TILDE)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var bwnot = new_node(OP_BWNOT, op);
		bwnot.v.unary = expr;
		return bwnot;
	}
	else if(this.match(TOKEN_MINUS)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var neg = new_node(OP_NEG, op);
		neg.v.unary = expr;
		return neg;
	}
	else if(this.match(TOKEN_BANG)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var not = new_node(OP_NOT, op);
		not.v.unary = expr;
		return not;
	}
	else if(this.match(TOKEN_AMP)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var addrOf = new_node(OP_ADDROF, op);
		addrOf.v.unary = expr;
		return addrOf;
	}
	else if(this.match(TOKEN_STAR)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var deref = new_node(OP_DEREF, op);
		deref.v.unary = expr;
		return deref;
	}

	return this.parse_value();
}

function Parser.parse_term(): Node* {
	var left = this.parse_unary();

	while(this.match(TOKEN_STAR) || this.match(TOKEN_SLASH) || this.match(TOKEN_PERCENT)) {
		var op = this.previous;

		var right = this.parse_unary();

		var type: int;
		if(op.type == TOKEN_STAR) type = OP_MUL;
		else if(op.type == TOKEN_SLASH) type = OP_DIV;
		else if(op.type == TOKEN_PERCENT) type = OP_MOD;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_arithmetic(): Node* {
	var left = this.parse_term();

	while(this.match(TOKEN_PLUS) || this.match(TOKEN_MINUS)) {
		var op = this.previous;

		var right = this.parse_term();

		var type: int;
		if(op.type == TOKEN_PLUS) type = OP_ADD;
		else if(op.type == TOKEN_MINUS) type = OP_SUB;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_shift(): Node* {
	var left = this.parse_arithmetic();

	while(this.match(TOKEN_LSH) || this.match(TOKEN_RSH)) {
		var op = this.previous;

		var right = this.parse_arithmetic();

		var type: int;
		if(op.type == TOKEN_LSH) type = OP_LSH;
		else if(op.type == TOKEN_RSH) type = OP_RSH;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_comparison(): Node* {
	var left = this.parse_shift();

	while(this.match(TOKEN_LESS) || this.match(TOKEN_LEQ)
	     || this.match(TOKEN_GREATER) || this.match(TOKEN_GEQ)) {
		var op = this.previous;

		var right = this.parse_shift();

		var type: int;
		if(op.type == TOKEN_LESS) type = OP_LESS;
		else if(op.type == TOKEN_LEQ) type = OP_LESS_EQ;
		else if(op.type == TOKEN_GREATER) type = OP_GREATER;
		else if(op.type == TOKEN_GEQ) type = OP_GREATER_EQ;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_equality(): Node* {
	var left = this.parse_comparison();

	while(this.match(TOKEN_EQEQ) || this.match(TOKEN_BANG_EQ)) {
		var op = this.previous;

		var right = this.parse_comparison();

		var type: int;
		if(op.type == TOKEN_EQEQ) type = OP_EQUAL;
		else if(op.type == TOKEN_BANG_EQ) type = OP_NOT_EQUAL;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_bwand(): Node* {
	var left = this.parse_equality();

	while(this.match(TOKEN_AMP)) {
		var op = this.previous;

		var right = this.parse_equality();

		var binary = new_node(OP_BWAND, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_xor(): Node* {
	var left = this.parse_bwand();

	while(this.match(TOKEN_XOR)) {
		var op = this.previous;

		var right = this.parse_bwand();

		var binary = new_node(OP_XOR, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_bwor(): Node* {
	var left = this.parse_xor();

	while(this.match(TOKEN_BAR)) {
		var op = this.previous;

		var right = this.parse_xor();

		var binary = new_node(OP_BWOR, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_ternary_expression(): Node* {
	var condition = this.parse_bwor();

	if(this.match(TOKEN_QUESTION)) {
		var op = this.previous;
		var doTrue = this.parse_expression();

		this.consume(TOKEN_COLON, "Expected ':' after true branch of ternary expression");

		var doFalse = this.parse_expression();

		var ternary = new_node(OP_TERNARY, op);
		ternary.v.conditional.condition = condition;
		ternary.v.conditional.doTrue = doTrue;
		ternary.v.conditional.doFalse = doFalse;
		return ternary;
	}

	return condition;
}

function Parser.parse_expression(): Node* {
	return this.parse_ternary_expression();
}

function Parser.parse_if_statement(): Node* {
	var ifStmt = new_node(AST_IF, this.previous);

	this.consume(TOKEN_LEFT_PAREN, "Expected '(' after if");

	ifStmt.v.conditional.condition = this.parse_expression();

	this.consume(TOKEN_RIGHT_PAREN, "Expected ')' after if condition");

	ifStmt.v.conditional.doTrue = this.parse_statement();

	if(this.match(TOKEN_ELSE)) {
		ifStmt.v.conditional.doFalse = this.parse_statement();
	}

	return ifStmt;
}

function Parser.parse_while_statement(): Node* {
	var whileStmt = new_node(AST_WHILE, this.previous);

	this.consume(TOKEN_LEFT_PAREN, "Expected '(' after while");

	whileStmt.v.conditional.condition = this.parse_expression();

	this.consume(TOKEN_RIGHT_PAREN, "Expected ')' after while condition");

	whileStmt.v.conditional.doTrue = this.parse_statement();

	return whileStmt;
}

function Parser.parse_for_statement(): Node* {
	var forStmt = new_node(AST_FOR, this.previous);

	this.consume(TOKEN_LEFT_PAREN, "Expected '(' after for");

	if(this.match(TOKEN_SEMICOLON)) {
		// No initialiser clause
	}
	else if(this.match(TOKEN_VAR)) {
		forStmt.v.loop.initial = this.parse_var_declaration();
	}
	else if(this.match(TOKEN_IDENTIFIER)) {
		forStmt.v.loop.initial = this.parse_statement();
	}
	else {
		this.error_current("Expected for initializer clause");
	}

	if(!this.match(TOKEN_SEMICOLON)) {
		forStmt.v.loop.condition = this.parse_expression();
		this.consume(TOKEN_SEMICOLON, "Expected ';' after condition");
	}

	if(!this.match(TOKEN_RIGHT_PAREN)) {
		forStmt.v.loop.iteration = this.parse_expression();
		this.consume(TOKEN_RIGHT_PAREN, "Expected ')' after for clauses");
	}

	forStmt.v.loop.body = this.parse_statement();

	return forStmt;
}

function Parser.parse_return_statement(): Node* {
	var returnStmt = new_node(AST_RETURN, this.previous);
	returnStmt.v.unary = this.parse_expression();

	this.consume(TOKEN_SEMICOLON, "Expected ';' after return statement");

	return returnStmt;
}

function Parser.parse_var_declaration(): Node* {
	var name = this.consume(TOKEN_IDENTIFIER, "Expected variable name");

	var type = VOID_TYPE;

	if(this.match(TOKEN_COLON)) {
		type = this.parse_type();
	}

	var value: Node* = null;

	if(this.match(TOKEN_EQ)) {
		value = this.parse_expression();
	}

	this.consume(TOKEN_SEMICOLON, "Expected ';' after variable declaration");

	var variable = new_node(AST_DEFINE_VAR, name);
	variable.v.variable.name = name;
	variable.v.variable.type = type;
	variable.v.variable.value = value;

	return variable;
}

function Parser.parse_statement(): Node* {
	if(this.match(TOKEN_IF)) {
		return this.parse_if_statement();
	}
	else if(this.match(TOKEN_FOR)) {
		return this.parse_for_statement();
	}
	else if(this.match(TOKEN_RETURN)) {
		return this.parse_return_statement();
	}
	else if(this.match(TOKEN_VAR)) {
		return this.parse_var_declaration();
	}
	else if(this.match(TOKEN_WHILE)) {
		return this.parse_while_statement();
	}
	else if(this.match(TOKEN_IDENTIFIER)) {
		var expr = this.parse_identifier();

		if(expr == null) return null;

		if(expr.type == AST_ACCESS_VAR) {
			this.error_current("Expected statement");
		}

		this.consume(TOKEN_SEMICOLON, "Expected ';' after expression");

		var exprStmt = new_node(AST_EXPR_STMT, expr.position);
		exprStmt.v.unary = expr;
		return exprStmt;
	}
	else if(this.match(TOKEN_LEFT_BRACE)) {
		return this.parse_block();
	}

	this.error_current("Expected statement");

	return null;
}

function Parser.parse_block(): Node* {
	var block = new_node(AST_BLOCK, this.previous);
	block.v.block.children = new_vector();
	block.v.block.parent = this.currentBlock;
	this.currentBlock = block;

	while(!this.check(TOKEN_RIGHT_BRACE)) {
		var stmt = this.parse_statement();
		if(this.error) break;
		block.add_child(stmt);
	}

	this.consume(TOKEN_RIGHT_BRACE, "Expected '}' after block");

	this.currentBlock = block.v.block.parent;
	return block;
}

function Parser.parse_function(): Node* {
	var name = this.consume(TOKEN_IDENTIFIER, "Expected function name");

	var funktion = new_node(AST_FUNCTION, name);
	funktion.v.funktion.name = name;
	funktion.v.funktion.arguments = new_vector();

	this.consume(TOKEN_LEFT_PAREN, "Expected '(' after function name");
	
	if(!this.check(TOKEN_RIGHT_PAREN)) {
		var argName = this.consume(TOKEN_IDENTIFIER, "Expected parameter name");
		this.consume(TOKEN_COLON, "Expected ':' after parameter name");
		var type = this.parse_type();

		var arg = new_node(AST_DEFINE_VAR, argName);
		arg.v.variable.name = argName;
		arg.v.variable.type = type;
		funktion.v.funktion.arguments.push(arg);

		while(this.match(TOKEN_COMMA)) {
			var argName = this.consume(TOKEN_IDENTIFIER, "Expected parameter name");
			this.consume(TOKEN_COLON, "Expected ':' after parameter name");
			var type = this.parse_type();

			var arg = new_node(AST_DEFINE_VAR, argName);
			arg.v.variable.name = argName;
			arg.v.variable.type = type;

			funktion.v.funktion.arguments.push(arg);
		}
	}

	this.consume(TOKEN_RIGHT_PAREN, "Expected ')' after function parameters");

	var type: Type*;

	if(this.match(TOKEN_COLON)) {
		type = this.match(TOKEN_VOID) ? VOID_TYPE : this.parse_type();
	}
	else {
		type = VOID_TYPE;
	}

	this.consume(TOKEN_LEFT_BRACE, "Expected '{' before function body");

	funktion.v.funktion.returnType = type;

	this.currentFunction = funktion;

	this.functions.push(funktion);

	var body = this.parse_block();

	funktion.v.funktion.body = body;

	return funktion;
}

function Parser.add_implicit_printu_function() {
	var name = synthetic_token(TOKEN_IDENTIFIER, "printu");
	var funktion = new_node(AST_FUNCTION, name);
	funktion.v.funktion.name = name;

	funktion.v.funktion.arguments = new_vector();

	var valTok = synthetic_token(TOKEN_IDENTIFIER, "value");
	var val = new_node(AST_DEFINE_VAR, valTok);
	val.v.variable.name = valTok;
	val.v.variable.type = INT_TYPE;
	funktion.v.funktion.arguments.push(val);

	funktion.v.funktion.returnType = VOID_TYPE;

	funktion.v.funktion.hasImplicitBody = true;

	this.functions.push(funktion);
}

function Parser.parse_program(): Node* {
	var program = new_node(AST_PROGRAM, this.current);
	program.v.block.children = new_vector();

	this.advance();

	this.add_implicit_printu_function();

	while(!this.match(TOKEN_EOF)) {
		if(this.match(TOKEN_FUNCTION)) {
			var funktion = this.parse_function();
			program.add_child(funktion);
		}
		else if(this.match(TOKEN_VAR)) {
			var variable = this.parse_var_declaration();
			variable.type = AST_DEFINE_GLOBAL_VAR;
			program.add_child(variable);
		}
		else {
			this.error_current("Expected definition");
			break;
		}
	}

	return program;
}