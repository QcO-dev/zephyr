import "std/core.zpr";
import "zpr/types.zpr";
import "zpr/lexer.zpr";
import "zpr/ast.zpr";

struct Parser {
	lexer: Lexer*;
	current: Token*;
	previous: Token*;

	currentFunction: Node*;
	functions: Vector*;

	error: int;
	panic: int;
}

function new_parser(lexer: Lexer*): Parser* {
	var parser: Parser* = malloc(sizeof(Parser));
	parser.lexer = lexer;
	parser.functions = new_vector();
	return parser;
}

function new_node(type: int, position: Token*): Node* {
	var node: Node* = malloc(sizeof(Node));
	node.type = type;
	node.position = position;
	return node;
}

function Node.add_child(child: Node*) {
	this.v.block.children.push(child);
}

function Parser.error_at_token(token: Token*, message: i8*) {
	if(this.panic) return;
	this.panic = true;
	eputs("["); eputd(token.line); eputs("] Error");

	if(token.type == TOKEN_EOF) {
		eputs(" @ EOF");
	}
	else if(token.type == TOKEN_ERROR) {
		// No value to print
	}
	else {
		eputs(" @ '"); eput_token_string(token); eputs("'");
	}

	eputs(": "); eputsln(message);

	this.error = true;
}

function Parser.error(message: i8*) {
	this.error_at_token(this.previous, message);
}

function Parser.error_current(message: i8*) {
	this.error_at_token(this.current, message);
}

function Parser.advance() {
	this.previous = this.current;

	for(;;) {
		this.current = this.lexer.next();
		if(this.current.type != TOKEN_ERROR) break;

		this.error_current(this.current.start);
	}
}

function Parser.consume(type: int, message: i8*): Token* {
	if(this.current.type == type) {
		this.advance();
		return this.previous;
	}

	this.error_current(message);
	return this.current;
}

function Parser.check(type: int): int {
	return this.current.type == type;
}

function Parser.match(type: int): int {
	if(!this.check(type)) return false;
	this.advance();
	return true;
}

function Parser.parse_type(): Type* {
	this.advance();

	var type = new_type();

	if(this.previous.type == TOKEN_INT) type.type = DATA_TYPE_INT;
	else {
		this.error("Expected type");
	}
	return type;
}

function Parser.parse_identifier(): Node* {
	var name = this.previous;

	if(this.match(TOKEN_EQ)) {
		var value = this.parse_expression();

		var assign = new_node(AST_ASSIGN_VAR, name);
		assign.v.variable.name = name;
		assign.v.variable.value = value;
		return assign;
	}
	else if(this.match(TOKEN_LEFT_PAREN)) {
		var call = new_node(AST_CALL, name);
		call.v.funktion.name = name;
		call.v.funktion.arguments = new_vector();

		if(!this.check(TOKEN_RIGHT_PAREN)) {
			var arg = this.parse_expression();

			call.v.funktion.arguments.push(arg);

			while(this.match(TOKEN_COMMA)) {
				var arg = this.parse_expression();

				call.v.funktion.arguments.push(arg);
			}
		}

		this.consume(TOKEN_RIGHT_PAREN, "Expected ')' after function arguments");

		return call;
	}

	var access = new_node(AST_ACCESS_VAR, name);
	access.v.variable.name = name;
	return access;
}

function Parser.parse_value(): Node* {
	if(this.match(TOKEN_INT_LITERAL)) {
		var literal = this.previous;
		if(this.error) return null;

		var literalNode = new_node(AST_INT_LITERAL, literal);
		var type = *INT_TYPE;
		literalNode.v.literal.type = type;
		literalNode.v.literal.az.integer = atoi(literal.start);

		return literalNode;
	}
	else if(this.match(TOKEN_IDENTIFIER)) {
		return this.parse_identifier();
	}
	else if(this.match(TOKEN_LEFT_PAREN)) {
		var expr = this.parse_expression();
		this.consume(TOKEN_RIGHT_PAREN, "Expected closing ')' after expression");
		return expr;
	}

	this.error_current("Expected value");
	return null;
}

function Parser.parse_unary(): Node* {
	if(this.match(TOKEN_TILDE)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var bwnot = new_node(OP_BWNOT, op);
		bwnot.v.unary = expr;
		return bwnot;
	}
	else if(this.match(TOKEN_MINUS)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var neg = new_node(OP_NEG, op);
		neg.v.unary = expr;
		return neg;
	}
	else if(this.match(TOKEN_BANG)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var not = new_node(OP_NOT, op);
		not.v.unary = expr;
		return not;
	}

	return this.parse_value();
}

function Parser.parse_term(): Node* {
	var left = this.parse_unary();

	while(this.match(TOKEN_STAR) || this.match(TOKEN_SLASH) || this.match(TOKEN_PERCENT)) {
		var op = this.previous;

		var right = this.parse_unary();

		var type: int;
		if(op.type == TOKEN_STAR) type = OP_MUL;
		else if(op.type == TOKEN_SLASH) type = OP_DIV;
		else if(op.type == TOKEN_PERCENT) type = OP_MOD;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_arithmetic(): Node* {
	var left = this.parse_term();

	while(this.match(TOKEN_PLUS) || this.match(TOKEN_MINUS)) {
		var op = this.previous;

		var right = this.parse_term();

		var type: int;
		if(op.type == TOKEN_PLUS) type = OP_ADD;
		else if(op.type == TOKEN_MINUS) type = OP_SUB;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_shift(): Node* {
	var left = this.parse_arithmetic();

	while(this.match(TOKEN_LSH) || this.match(TOKEN_RSH)) {
		var op = this.previous;

		var right = this.parse_arithmetic();

		var type: int;
		if(op.type == TOKEN_LSH) type = OP_LSH;
		else if(op.type == TOKEN_RSH) type = OP_RSH;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_comparison(): Node* {
	var left = this.parse_shift();

	while(this.match(TOKEN_LESS) || this.match(TOKEN_LEQ)
	     || this.match(TOKEN_GREATER) || this.match(TOKEN_GEQ)) {
		var op = this.previous;

		var right = this.parse_shift();

		var type: int;
		if(op.type == TOKEN_LESS) type = OP_LSH;
		else if(op.type == TOKEN_LEQ) type = OP_LESS_EQ;
		else if(op.type == TOKEN_GREATER) type = OP_GREATER;
		else if(op.type == TOKEN_GEQ) type = OP_GREATER_EQ;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_equality(): Node* {
	var left = this.parse_comparison();

	while(this.match(TOKEN_EQEQ) || this.match(TOKEN_BANG_EQ)) {
		var op = this.previous;

		var right = this.parse_comparison();

		var type: int;
		if(op.type == TOKEN_EQEQ) type = OP_EQUAL;
		else if(op.type == TOKEN_BANG_EQ) type = OP_NOT_EQUAL;

		var binary = new_node(type, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_bwand(): Node* {
	var left = this.parse_equality();

	while(this.match(TOKEN_AMP)) {
		var op = this.previous;

		var right = this.parse_equality();

		var binary = new_node(OP_BWAND, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_xor(): Node* {
	var left = this.parse_bwand();

	while(this.match(TOKEN_XOR)) {
		var op = this.previous;

		var right = this.parse_bwand();

		var binary = new_node(OP_XOR, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_bwor(): Node* {
	var left = this.parse_xor();

	while(this.match(TOKEN_BAR)) {
		var op = this.previous;

		var right = this.parse_xor();

		var binary = new_node(OP_BWOR, op);
		binary.v.binary.lhs = left;
		binary.v.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_expression(): Node* {
	return this.parse_bwor();
}

function Parser.parse_return_statement(): Node* {
	var returnStmt = new_node(AST_RETURN, this.previous);
	returnStmt.v.unary = this.parse_expression();

	this.consume(TOKEN_SEMICOLON, "Expected ';' after return statement");

	return returnStmt;
}

function Parser.parse_var_declaration(): Node* {
	var name = this.consume(TOKEN_IDENTIFIER, "Expected variable name");

	this.consume(TOKEN_COLON, "Expected ':' after variable name");

	var type = this.parse_type();

	var value: Node* = null;

	if(this.match(TOKEN_EQ)) {
		value = this.parse_expression();
	}

	this.consume(TOKEN_SEMICOLON, "Expected ';' after variable declaration");

	var variable = new_node(AST_DEFINE_VAR, name);
	variable.v.variable.name = name;
	var dtype = *type;
	variable.v.variable.type = dtype;
	variable.v.variable.value = value;

	return variable;
}

function Parser.parse_statement(): Node* {
	if(this.match(TOKEN_RETURN)) {
		return this.parse_return_statement();
	}
	else if(this.match(TOKEN_VAR)) {
		return this.parse_var_declaration();
	}
	else if(this.match(TOKEN_IDENTIFIER)) {
		var expr = this.parse_identifier();

		if(expr == null) return null;

		if(expr.type == AST_ACCESS_VAR) {
			this.error_current("Expected statement");
		}

		this.consume(TOKEN_SEMICOLON, "Expected ';' after expression");

		var exprStmt = new_node(AST_EXPR_STMT, expr.position);
		exprStmt.v.unary = expr;
		return exprStmt;
	}

	this.error_current("Expected statement");

	return null;
}

function Parser.parse_block(): Node* {
	var block = new_node(AST_BLOCK, this.previous);
	block.v.block.children = new_vector();

	while(!this.check(TOKEN_RIGHT_BRACE)) {
		var stmt = this.parse_statement();
		if(this.error) break;
		block.add_child(stmt);
	}

	this.consume(TOKEN_RIGHT_BRACE, "Expected '}' after block");

	return block;
}

function Parser.parse_function(): Node* {
	var name = this.consume(TOKEN_IDENTIFIER, "Expected function name");

	var funktion = new_node(AST_FUNCTION, name);
	funktion.v.funktion.name = name;
	funktion.v.funktion.arguments = new_vector();

	this.consume(TOKEN_LEFT_PAREN, "Expected '(' after function name");
	
	if(!this.check(TOKEN_RIGHT_PAREN)) {
		var argName = this.consume(TOKEN_IDENTIFIER, "Expected parameter name");
		this.consume(TOKEN_COLON, "Expected ':' after parameter name");
		var type = this.parse_type();

		var arg = new_node(AST_DEFINE_VAR, argName);
		arg.v.variable.name = argName;
		var dtype = *type;
		arg.v.variable.type = dtype;
		funktion.v.funktion.arguments.push(arg);

		while(this.match(TOKEN_COMMA)) {
			var argName = this.consume(TOKEN_IDENTIFIER, "Expected parameter name");
			this.consume(TOKEN_COLON, "Expected ':' after parameter name");
			var type = this.parse_type();

			var arg = new_node(AST_DEFINE_VAR, argName);
			arg.v.variable.name = argName;
			var dtype = *type;
			arg.v.variable.type = dtype;

			funktion.v.funktion.arguments.push(arg);
		}
	}

	this.consume(TOKEN_RIGHT_PAREN, "Expected ')' after function parameters");

	var type: Type*;

	if(this.match(TOKEN_COLON)) {
		type = this.match(TOKEN_VOID) ? VOID_TYPE : this.parse_type();
	}
	else {
		type = VOID_TYPE;
	}

	this.consume(TOKEN_LEFT_BRACE, "Expected '{' before function body");

	var dtype = *type;
	funktion.v.funktion.returnType = dtype;

	this.currentFunction = funktion;

	this.functions.push(funktion);

	var body = this.parse_block();

	funktion.v.funktion.body = body;

	return funktion;
}

function Parser.parse_program(): Node* {
	var program = new_node(AST_PROGRAM, this.current);
	program.v.block.children = new_vector();

	this.advance();

	while(!this.match(TOKEN_EOF)) {
		if(this.match(TOKEN_FUNCTION)) {
			var funktion = this.parse_function();
			program.add_child(funktion);
		}
		else {
			this.error_current("Expected definition");
			break;
		}
	}

	return program;
}